# PTA团队天梯赛║L1-002 打印沙漏

## 一、题目要求

> 本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印
>
> ```
> *****
>  ***
>   *
>  ***
> *****
> ```
>
> 所谓“沙漏形状”，是指**每行输出奇数个符号**；各行**符号中心对齐**；**相邻两行符号数差2**；符号数先**从大到小顺序递减到1**，再从小到大顺序递增；首尾符号数相等。
>
> 给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。
>

### 输入格式：

输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。

### 输出格式：

首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。

### 输入样例：

```in
19 *
```

### 输出样例：

```out
*****
 ***
  *
 ***
*****
2
```

## 二、解题思路

该题目为图形输出类的问题，关键是找到图形输出的规律，由题目找寻下述规律

```
沙漏形状行数必然是奇数(1,3,5,...,2x+1) //x=0,1,2,3,...
行数为1时，符号数为1
行数为3时，符号数为7，即1+2*3
行数为5时，符号数为17，即1+2*3+2*5
...
行数为i时，符号数为1+2*3+2*5+...+2*i
```

因此，先设置打印的沙漏层数 *level* 和 沙漏符号数 *hourglass* 为1(若用户输入符号数不为0，则至少可以打印一层沙漏)，用 while 循环累加 *level* 和 *hourglass* 直到能打印最多符号，最后先打印上半部分以及最中心的一个符号，再打印剩余部分的沙漏。

## 三、代码

```c++
#include <iostream>
using namespace std;

int main()
{
    int n, level = 1; //n为用户输入的符号数，level为打印的沙漏层数
    int hourglass = 1; //沙漏符号数
    char c; //用户输入的符号
    cin >> n;
    cin >> c;

    while(n / hourglass) //累加寻找能打印的最大沙漏
    {
        level += 2; //层数上下各加一层
        hourglass += 2 * level; //沙漏符号数也增加
    }
    //while循环最后一次多加了一次要减去
    hourglass -= 2*level; //注意两个算式顺序不能调换
    level -= 2;

    //打印上半个沙漏
    for(int i=0; i < level/2 + 1; i++)
    {
        for(int k=0; k < i; k++) cout << " ";
        for(int m=0 ;m < level-2*i;m++) cout << c;
        cout << endl;
    }
    //打印下半个沙漏
    for(int i=level/2; i >0 ; i--)
    {
        for(int k=0; k < i-1; k++) cout << " ";
        for(int m=0 ;m < level-2*(i-1); m++) cout << c;
        cout << endl;
    }
    cout << n - hourglass << endl;

    return 0;
}
```

## 四、问题反思

1. 在while循环寻找能打印的最大沙漏时，最后减去多加的两层时算数顺序不能调换，第一次因为调换了两个算式顺序导致打印出的沙漏出错。
2. 打印上半个沙漏时第一次尝试未将最中间一层考虑进去，将问题复杂化了。
3. 做完打印沙漏部分却遗漏了最后一步输出剩下未使用的符号数，得意忘形，粗心大意了，以后做题中谨记戒骄戒躁，认真阅读题目，做完题后检查一下是否完成全部要求。

---

# PTA团队天梯赛║L1-003 个位数统计

## 一、题目要求

> 给定一个 *k* 位整数 *N*=*d*<sub>k−1</sub>10*<sup>k−1</sup>*+⋯+*d*<sub>1</sub>10<sup>1</sup>+*d*<sub>0</sub> (0≤*d<sub>i</sub>*≤9, *i*=0,⋯,*k*−1, *d*<sub>k−1</sub>>0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定 *N*=100311，则有 2 个 0，3 个 1，和 1 个 3。

### 输入格式：

每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 *N*。

### 输出格式：

对 *N* 中每一种不同的个位数字，以 `D:M` 的格式在一行中输出该位数字 `D` 及其在 *N* 中出现的次数 `M`。要求按 `D` 的升序输出。

### 输入样例：

```in
100311
```

### 输出样例：

```out
0:2
1:3
3:1
```

## 二、解题思路

利用**字符串**解决该问题，首先以字符串的形式存储用户输入的数据，接着用一个0~9的字符数组存储各位上出现的数字次数，最后顺序输出字符数组中非零的数以及存储的出现次数。

## 三、代码

```c++
#include <iostream>
#include <cstring>
using namespace std;

int main()
{
    string s;
    int num[10] = {0};
    cin >> s;
    for(int i=0; i < s.length(); i++) //将输入数字的每一位数字所在的字符数组位置存储的次数加1
    {
        num[s[i]-'0']++;
    }
    for(int i=0; i < 10; i++) //输出
    {
        if(num[i])
        {
            cout << i << ":" << num[i] << endl;

        }
    }

    return 0;
}

```

## 四、问题反思

1. 起初使用 *int* 和 *long* 类型去存储测试用例，无法满足题目1000位数字的要求，且操作过程较为复杂，后转用 *string* 类型操作既简单又准确。
2. *string* 类型的字符串长度不能使用 *strlen()* 的方法获得，需要使用包装好string类里的函数方法 *string.length()* 来获取长度。

---

# PTA团队天梯赛║L1-004 **计算摄氏温度**

## 一、题目要求

> 给定一个华氏温度*F*，本题要求编写程序，计算对应的摄氏温度*C*。计算公式：*C*=5×(*F*−32)/9。题目保证输入与输出均在整型范围内。

### 输入格式:

输入在一行中给出一个华氏温度。

### 输出格式:

在一行中按照格式“Celsius = C”输出对应的摄氏温度C的整数值。

### 输入样例:

```in
150
```

### 输出样例:

```out
Celsius = 65
```

## 二、解题思路

该题为最简单的根据公式数值转换，注意题目要求 *保证输入与输出均在整型范围内*。

## 三、代码

```c++
#include <iostream>
#include <cstring>
using namespace std;

int main()
{
    int f,c;
    cin >> f;
    c = 5*(f-32)/9;
    cout << "Celsius = " << c << endl;

    return 0;
}

```

## 四、反思总结

题目有一些简单了，注意细心不要搞错输出时候的要求，以防检查测试不通过。

---

# PTA团队天梯赛║L1-005 **考试座位号**

## 一、题目要求

> 每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。

### 输入格式：

输入第一行给出一个正整数 *N*（≤1000），随后 *N* 行，每行给出一个考生的信息：`准考证号 试机座位号 考试座位号`。其中`准考证号`由 16 位数字组成，座位从 1 到 *N* 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。

考生信息之后，给出一个正整数 *M*（≤*N*），随后一行中给出 *M* 个待查询的试机座位号码，以空格分隔。

### 输出格式：

对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。

### 输入样例：

```in
4
3310120150912233 2 4
3310120150912119 4 1
3310120150912126 1 3
3310120150912002 3 2
2
3 4
```

### 输出样例：

```out
3310120150912002 2
3310120150912119 1
```

## 二、解题思路

利用结构体和 *vector* 容器结合，在输入的数据中找到符合条件的数据并输出。

## 三、代码

```c++
#include <iostream>
#include <vector>
using namespace std;

struct stu{ //创建一个结构体存储学生的准考证号以及试机和考试座位号
    string num; //准考证号
    int com1,com2; //com1为试机座位号，com2为考试座位号
};

int main()
{
    int n, m;   //n为考生数，m为待查询的考生数目
    cin >> n;
    vector<stu> a(n);
    for(int i = 0; i < n; i++)
    {
        cin >> a[i].num >> a[i].com1 >> a[i].com2;
    }
    cin >> m;
    int src; //待查询的试机座位号
    for(int i = 0; i < m; i++)
    {
        cin >> src;
        for(int j = 0; j < n; j++)
        {
            if(a[j].com1 == src)
            {
                cout << a[j].num << " " << a[j].com2 <<endl;
                break;
            }
        }
    }
    return 0;
}

```

## 四、反思总结

运用好 *vector* 容器后题目就变得较为简单了，题目难度不大。

[*vector* 简单的知识点](https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html)

---

# PTA团队天梯赛║L1-006 **连续因子**

## 一、题目要求

> 一个正整数 *N* 的因子中可能存在若干连续的数字。例如 630 可以分解为 3×5×6×7，其中 5、6、7 就是 3 个连续的数字。给定任一正整数 *N*，要求编写程序求出最长连续因子的个数，并输出最小的连续因子序列。

### 输入格式：

输入在一行中给出一个正整数 *N*（1<*N*<231）。

### 输出格式：

首先在第 1 行输出最长连续因子的个数；然后在第 2 行中按 `因子1*因子2*……*因子k` 的格式输出最小的连续因子序列，其中因子按递增顺序输出，1 不算在内。

### 输入样例：

```in
630
```

### 输出样例：

```out
3
5*6*7
```

## 二、解题思路

根据N的值的取值范围小于等于2<sup>31</sup>，而这个值介于12的阶乘到13的阶乘之间，所以我们可以得到最大的值应该是12个数连续相乘，又因为1不计算在内，所以最多只要有11为连续因子即可。

用暴力的思想，我从2、3、4...sqrt(N)开始乘，连着乘以11位，10位，9位...以此类推。

即连续乘 **11** 位：

> 2 3 4 5 6 7 8 9 10 11 12相乘
>
> 3 4 5 6 7 8 9 10 11 12 13相乘
>
> ...

连续乘 **10** 位：

> 2 3 4 5 6 7 8 9 10 11相乘
>
> 3 4 5 6 7 8 9 10 11 12相乘
>
> ...

直到只有 **1** 位时，过程中只要有一个乘积 **S** 使得 `N%S==0`，就可以认为找到了连续因子。

为了优化代码，在每次乘的时候如果当前的乘积已经大于 **N** 了，就没有继续乘的必要了。

## 三、代码

```c++
#include <iostream>
#include <cmath>
using namespace std;

int main()
{
    int N;
    cin >> N;
    int n = sqrt(N);
    int i, j;
    bool flag = false;
    long long int sum;  //注意数据类型！！
    for(int len=11; len>0; len--)   //用len控制连续因子个数，N最多只能到12阶乘
    {
        for(i=2; i<=n; i++) //连续因子不包括1，从2开始乘，最多乘到N的开方就足够
        {
            sum = 1;
            for(j=i; j<len+i; j++)    //从当前的i开始，乘以的个数为len的长度
            {
                sum*=j;
                if(sum>N) break;    //到这就没有必要往下算了
            }
            if(N%sum==0)    //当前的sum值是N的一个因子
            {
                cout << len << endl << i;
                for(int k=i+1; k<j; k++)
                {
                    cout << "*" << k;
                }
                cout << endl;
                flag = true;
            }
            if(flag) break;
        }
        if(flag) break;
    }

    return 0;
}

```

##  四、反思总结

![image-20210223220149631](C:\Users\79485\AppData\Roaming\Typora\typora-user-images\image-20210223220149631.png)

v1.0最后两个测试点没有通过，还没有想通是哪里出现问题。

# PTA团队天梯赛║L1-007 **念数字**

## 一、题目要求

> 输入一个整数，输出每个数字对应的拼音。当整数为负数时，先输出`fu`字。十个数字对应的拼音如下：
>
> 0: ling	1: yi	2: er	3: san	4: si	5: wu	6:liu	7:qi	8: ba	9: jiu
>

### 输入格式：

输入在一行中给出一个整数，如：`1234`。

**提示：整数包括负数、零和正数。**

### 输出格式：

在一行中输出这个整数对应的拼音，每个数字的拼音之间用空格分开，行末没有最后的空格。如 `yi er san si`。

### 输入样例：

```in
-600
```

### 输出样例：

```out
fu liu ling ling
```

## 二、解题思路

用户输入 *string* 类型数据，然后存放至 *char* 数组中，用 *switch* 判断输出相应位置的拼音

## 三、代码

```c++
#include <iostream>
#include <cstring>
using namespace std;

int main()
{
    string n;
    cin >> n;
    char a[20];
    int i = 0;
    for(int j=0; j < n.length(); j++)
    {
        a[j] = n[j];
    }

    while(i < n.length())
    {
        switch (a[i])
        {
        case '-':
            cout << "fu";
            break;
        case '0':
            cout << "ling";
            break;
        case '1':
            cout << "yi";
            break;
        case '2':
            cout << "er";
            break;
        case '3':
            cout << "san";
            break;
        case '4':
            cout << "si";
            break;
        case '5':
            cout << "wu";
            break;
        case '6':
            cout << "liu";
            break;
        case '7':
            cout << "qi";
            break;
        case '8':
            cout << "ba";
            break;
        case '9':
            cout << "jiu";
            break;
        }
        if(i == n.length() - 1) {cout << endl; break;}
        cout << " ";
        i++;
    }

    return 0;
}

```

## 四、反思总结

题目难度不大，但是一开始走了弯路，第一次想法为用 *int* 存储输入的整数，直接判断每一位上的数字较为麻烦复杂，因此改换为先使用 *string* 类型转存 *char* 数组的方式，更加简单快捷。主要实现功能部分用 *switch* 来实现。

---

# PTA团队天梯赛║L1-008 **求整数段和**

## 一、题目要求

> 给定两个整数*A*和*B*，输出从*A*到*B*的所有整数以及这些数的和。

### 输入格式：

输入在一行中给出2个整数*A*和*B*，其中−100≤*A*≤*B*≤100，其间以空格分隔。

### 输出格式：

首先顺序输出从*A*到*B*的所有整数，每5个数字占一行，每个数字占5个字符宽度，向右对齐。最后在一行中按`Sum = X`的格式输出全部数字的和`X`。

### 输入样例：

```in
-3 8
```

### 输出样例：

```out
   -3   -2   -1    0    1
    2    3    4    5    6
    7    8
Sum = 30
```

## 二、解题思路

用循环打出两个数之间的所有整数较为简单，需要注意的是要按照题目要求控制打印的格式，可以使用C语言风格的 *printf()* 式样化规定字符较为方便控制输出。

> 可以在“%”和字母之间插进数字表示最大[场宽](https://baike.baidu.com/item/场宽)。
>
> 例如：%3d表示输出3位整型数，不够3位右对齐。
>
> %9.2f表示输出场宽为9的浮点数，其中小数位为2，整数位为6，
>
> 小数点占一位，不够9位右对齐。

之后五个数字一换行，利用对5取余的办法控制。

## 三、代码

```c++
#include <iostream>
#include <stdio.h>
using namespace std;

int main()
{
    int a, b, sum = 0;
    cin >> a >> b;
    int j = 0;
    for(int i = a; i < b+1 ; i++)
    {
        printf("%5d",i); //每个数字占5个字符宽度，向右对齐
        sum += i;
        j++;
        if(j%5 == 0) cout << endl;
    }
    if(j%5 != 0 ) {cout << endl;}
    cout << "Sum = " << sum << endl;

    return 0;
}

```

## 四、反思总结

第一次提交只得了**9**分，提示格式错误扣了一分，查错发现原代码在输出最后的`Sum=`前直接输出了换行，如果要输出5的整数倍的数字，代码就会多出一空行，后加入

```
if(j%5 != 0 ) {cout << endl;}
```

控制空行的输出，重新提交得到满分。

---

# PTA团队天梯赛║L1-009 **N个数求和**

## 一、题目要求

本题的要求很简单，就是求`N`个数字的和。麻烦的是，这些数字是以有理数`分子/分母`的形式给出的，你输出的和也必须是有理数的形式。

### 输入格式：

输入第一行给出一个正整数`N`（≤100）。随后一行按格式`a1/b1 a2/b2 ...`给出`N`个有理数。题目保证所有分子和分母都在长整型范围内。另外，负数的符号一定出现在分子前面。

### 输出格式：

输出上述数字和的最简形式 —— 即将结果写成`整数部分 分数部分`，其中分数部分写成`分子/分母`，要求分子小于分母，且它们没有公因子。如果结果的整数部分为0，则只输出分数部分。

### 输入样例1：

```in
5
2/5 4/15 1/30 -2/60 8/3
```

### 输出样例1：

```out
3 1/3
```

### 输入样例2：

```in
2
4/3 2/3
```

### 输出样例2：

```out
2
```

### 输入样例3：

```in
3
1/3 -1/6 1/8
```

### 输出样例3：

```
7/24
```

## 二、解题思路

分数的和问题归根结底是通分时求最小公倍数和最大公因数的问题，将分子和分母分开进行运算，先求出所有分母的最小公倍数作为通分后的分母，然后求出通分后的分子之和，最后化简即可

## 三、代码

```c++
#include <iostream>
#include <stdio.h>
#include <cmath>

using namespace std;

long int gcd(long int a, long int b)    //求最大公因数
{
    return a%b==0 ? b : gcd(b,a%b);
}

int main()
{
    int a[100], b[100]; //存放输入的分子和分母
    long int s1 = 0;     //存放所有分数通分后的分子之和
    long int s2 = 1;     //存放当前分母最小的公倍数
    int N;
    cin >> N;
    for(int i=0; i<N; i++)
    {
        scanf("%d/%d", &a[i],&b[i]);
    }
    s2 = b[0];  //将b[0]作为初始分母最小公倍数

    for(int i=0; i<N; i++)  //求出分母的最小公倍数
    {
        s2 = s2*b[i] / gcd(s2,b[i]);
    }
    for(int i=0; i<N; i++)  //求出通分后的分子之和
    {
        s1 += s2/b[i] * a[i];
    }
    long int n = s1/s2; //最后结果整数部分
    long int m = abs(s1%s2); //余数
    if(m==0) //结果为整数
    {
        cout << n << endl;
    }
    else
    {
        if(n!=0)    //n==0时不输出n
        {
            cout << n << " ";
        }
        if(s1<0)    //如果结果为负数
        {
            cout << "-";
        }
        cout << m/gcd(s2,m) << "/" << s2/gcd(s2,m) << endl;     //将(分子/分母)化到最简
    }

    return 0;
}

```

## 四、反思总结

1. 由于输入时要输入分数，对于输入格式有要求，要求是 `a/b` 的格式，因此引入头文件 `#include <stdio.h>` ，利用C语言中 *scanf()* 实现更灵活的输入操作。
2. 由于求最小公倍数还有主函数内多次要求最大公因数，因此在主函数前写一个求最大公因数的全局函数大大方便了后续的操作。
3. 最后输出结果控制的时候，起初如果测试数据为负数总会输出错误，后发现是化简部分余数未保持正，因此解决方案是引入头文件 `#include <cmath>` 中 *abs()* 取绝对值。

# PTA团队天梯赛║L1-010 **比较大小**

## 一、题目要求

本题要求将输入的任意3个整数从小到大输出。

### 输入格式:

输入在一行中给出3个整数，其间以空格分隔。

### 输出格式:

在一行中将3个整数从小到大输出，其间以“->”相连。

### 输入样例:

```in
4 2 8
```

### 输出样例:

```out
2->4->8
```

## 二、解题思路

根据题目要求可以想到使用C++中的 *sort()* 函数自动进行排序

## 三、代码

```c++
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
    int a[3] = {};
    for(int i=0; i<3; i++)
    {
        cin >> a[i];
    }
    sort(a,a+3);
    cout << a[0];
    for(int i=1; i<3; i++)
    {
        cout << "->" << a[i];
    }
    cout << endl;

    return 0;
}

```

## 四、反思总结

要使用 *sort()* 函数要引用头文件 *#include <algorithm>* 。

# PTA团队天梯赛║L1-011 A-B

## 一、题目要求

本题要求你计算 *A*−*B* 。不过麻烦的是，*A*和*B*都是字符串 —— 即从字符串*A*中把字符串*B*所包含的字符全删掉，剩下的字符组成的就是字符串 *A*−*B* 。

### 输入格式：

输入在2行中先后给出字符串*A*和*B*。两字符串的长度都不超过104，并且保证每个字符串都是由可见的ASCII码和空白字符组成，最后以换行符结束。

### 输出格式：

在一行中打印出*A*−*B*的结果字符串。

### 输入样例：

```in
I love GPLT!  It's a fun game!
aeiou
```

### 输出样例：

```out
I lv GPLT!  It's  fn gm!
```

## 二、解题思路

设置一个flag，暴力循环比较a字符串的每一个字符是否与b字符串中的字符相同，如果发现相同，flag更新为false，最后用 **if(flag)** 控制输出a字符串

## 三、代码

```c++
#include <iostream>
#include <cstring>
using namespace std;

int main()
{
    string a, b;
    getline(cin,a);
    getline(cin,b);
    bool flag;
    size_t len = a.length();
    size_t len2 = b.length();
    for (int i = 0; i < len; ++i)
	{
        flag = true;
        for (int j = 0; j < len2; ++j)
		{
            if (b[j] == a[i])
			{
                flag = false;
                break;
            }
        }
        if (flag)
		{
            cout << a[i];
        }
    }
    cout << endl;

    return 0;
}

```

## 四、反思总结

程序时间复杂度为O(n<sup>2</sup>),程序耗时很长![image-20210303190909453](C:\Users\79485\AppData\Roaming\Typora\typora-user-images\image-20210303190909453.png)

网上看到柳诺大神巧妙的方法将时间复杂度降到O(n),思路与代码如下

> **分析：辣么多ASCII码也在0~255之间，所以用book数组标记所有的ASCII码～如果第二个字符出现了这个ACSII码那就标记为1~然后输出的时候当book数组对应的那个ASCII为1的时候就跳过不输出～**
>
> *引自https://www.liuchuo.net/archives/1597*

```c++
#include <iostream>
using namespace std;
int book[256];
int main() {
    string s, a;
    getline(cin, s);
    getline(cin, a);
    for(int i = 0; i < a.length(); i++) book[a[i]] = 1;
    for(int i = 0; i < s.length(); i++) {
        if(book[s[i]] == 1) continue;
        cout << s[i];
    }
    return 0;
}
```

在测试点1和3耗时大为降低![image-20210303191227350](C:\Users\79485\AppData\Roaming\Typora\typora-user-images\image-20210303191227350.png)

# PTA团队天梯赛║L1-013 **计算阶乘和**

## 一、题目要求

对于给定的正整数*N*，需要你计算 *S*=1!+2!+3!+...+*N*!。

### 输入格式：

输入在一行中给出一个不超过10的正整数*N*。

### 输出格式：

在一行中输出*S*的值。

### 输入样例：

```in
3
```

### 输出样例：

```out
9
```

## 二、解题思路

利用两层循环计算，内循环计算每个数的阶乘，外循环将内循环所求阶乘累加得到结果。

## 三、代码

```c++
#include <iostream>
using namespace std;

int main()
{
    int n, sum = 0;
    cin >> n;
    for(int i=1; i<=n; i++)
    {
        int k = 1;
        for(int j=1; j<=i; j++)
        {
            k*=j;
        }
        sum+=k;
    }
    cout << sum << endl;

    return 0;
}

```

## 四、反思总结

弄清楚两层循环的逻辑，实现起来较为简单。

# PTA团队天梯赛║L1-015 **跟奥巴马一起画方块**

## 一、题目要求

美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！

### 输入格式：

输入在一行中给出正方形边长*N*（3≤*N*≤21）和组成正方形边的某种字符`C`，间隔一个空格。

### 输出格式：

输出由给定字符`C`画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的50%（四舍五入取整）。

### 输入样例：

```in
10 a
```

### 输出样例：

```out
aaaaaaaaaa
aaaaaaaaaa
aaaaaaaaaa
aaaaaaaaaa
aaaaaaaaaa
```

## 二、解题思路

题目关键在于控制输出，因为是整数除以2，所以四舍五入利用偶数直接除以，奇数将除以结果加一实现，然后用两层循环输出，内循环输出一行内所有字符，外循环输出空行保证有字符的行数是列数的50%。

## 三、代码

```c++
#include <iostream>

using namespace std;

int main()
{
   int n, p;
   char c;
   cin >> n >> c;
   if(n<3 || n>21) return 0;

   if(n%2==0) p = n/2;  //控制四舍五入
   else p = n/2 + 1;

   for(int i=0; i<p; i++)
   {
       for(int j=0; j<n; j++)
       {
           cout << c;
       }
       cout << endl;
   }

    return 0;
}

```

## 四、反思总结

题目难度不大，掌握好行与列输出的关系比较容易解题。

# PTA团队天梯赛║L1-016 **查验身份证**

## 一、题目要求

一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：

首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值`Z`；最后按照以下关系对应`Z`值与校验码`M`的值：

```
Z：0 1 2 3 4 5 6 7 8 9 10
M：1 0 X 9 8 7 6 5 4 3 2
```

现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。

### 输入格式：

输入第一行给出正整数*N*（≤100）是输入的身份证号码的个数。随后*N*行，每行给出1个18位身份证号码。

### 输出格式：

按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出`All passed`。

### 输入样例1：

```in
4
320124198808240056
12010X198901011234
110108196711301866
37070419881216001X
```

### 输出样例1：

```out
12010X198901011234
110108196711301866
37070419881216001X
```

### 输入样例2：

```
2
320124198808240056
110108196711301862
```

### 输出样例2：

```
All passed
```

## 二、解题思路

设置 ***flag*** 为`true`，检验前17位是否都为数字可以使用ASCII码是否在48~57范围内检验，根据对前17位数字加权求和后对11取模运算所得结果作为M数组下标，M数组存放校验码，比对第18位数字与校验码，一旦这两步任意步骤有误，更新 ***flag*** 为`false`，最后若 ***flag*** 为`true`就输出`All passed`,否则顺序输出有误身份证。

## 三、代码

```cpp
//v1.0 得分10分，测试点2未通过
#include <iostream>
#include <cstring>

using namespace std;

int main()
{

    int N;
    cin >> N;
    string s;
    bool flag1 = 1; //前十七位是否全为数字
    bool flag2 = 1; //校验码是否正确
    bool flag = 1;  //是否所有号码都正确
    int h[17] = {7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};
    char m[11] = {'1','0','X','9','8','7','6','5','4','3','2'};
    for(int i=0; i<N; i++)
    {
        cin >> s;
        int sum = 0;
        
        for(int j=0; j<17;j++)
        {
            if(s[j]<'0' || s[j]>'9')
            {
                flag1 = 0;
                break;
            }
            sum += (s[j]-'0')*h[j];
        }
        if(m[sum%11] != s[17])
            flag2 = 0;
        if(!flag1 || !flag2)
        {
            cout << s << endl;
            flag = 0;
        }
    }
    if(flag)
        cout << "All passed" << endl;


    return 0;
}

//v2.0 满分
#include <iostream>
#include <cstring>

using namespace std;

int main()
{

    int N;
    cin >> N;
    string s;
    bool flag1 = 1; //前十七位是否全为数字
    bool flag2 = 1; //校验码是否正确
    bool flag = 1;  //是否所有号码都正确
    int h[17] = {7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};
    char m[11] = {'1','0','X','9','8','7','6','5','4','3','2'};
    for(int i=0; i<N; i++)
    {
        cin >> s;
        int sum = 0;
        flag1 = 1;	//重置
        flag2 = 1;
        for(int j=0; j<17;j++)
        {
            if(s[j]<'0' || s[j]>'9')
            {
                flag1 = 0;
                break;
            }
            sum += (s[j]-'0')*h[j];
        }
        if(m[sum%11] != s[17])
            flag2 = 0;
        if(!flag1 || !flag2)
        {
            cout << s << endl;
            flag = 0;
        }
    }
    if(flag)
        cout << "All passed" << endl;


    return 0;
}

```

## 四、反思总结

第一次代码提交只得了10分，测试点2未通过，后发现是在检查完一个身份证号码后，进入下一个身份证号码检查时flag1和flag2未重置，修正后满分通过。

# PTA团队天梯赛║L1-017 **到底有多二**

## 一、题目要求

一个整数“**犯二的程度**”定义为该数字中包含2的个数与其位数的比值。如果这个数是负数，则程度增加0.5倍；如果还是个偶数，则再增加1倍。例如数字`-13142223336`是个11位数，其中有3个2，并且是负数，也是偶数，则它的犯二程度计算为：3/11×1.5×2×100%，约为81.82%。本题就请你计算一个给定整数到底有多二。

### 输入格式：

输入第一行给出一个不超过50位的整数`N`。

### 输出格式：

在一行中输出`N`犯二的程度，保留小数点后两位。

### 输入样例：

```in
-13142223336
```

### 输出样例：

```out
81.82%
```

## 二、解题思路

设置两个倍数标志 `fu` 和 `ou` 初始值均为 **1** ，用字符串存储输入的整数，先判断第一位是否为 **’-‘** ，若是负数，更新 `fu` 为 **1.5** ，并在计算字符串长度时减一，然后判断该整数是否为偶数，若是，更新 `ou` 为 **2** 。然后遍历字符串计数 **’2‘** 的个数，根据题目要求计算得出结果，结果输出保留两位小数。

## 三、代码

```c++
#include <iostream>
#include <stdio.h>
#include <cstring>
using namespace std;

int main()
{
    string s;
    float fu = 1;
    int ou = 1;
    int two = 0;
    double sum;
    cin >> s;
    int len = s.length();

    if(s[0] == '-')     //判断负数
    {
        fu = 1.5;
        len -= 1;
    }
    if((s[s.length()-1]-'0')%2 == 0)  //判断偶数
    {
        ou = 2;
    }
    for(int i=0; i<s.length(); i++)     //计数2的个数
    {
        if(s[i] == '2')
        {
            two += 1;
        }
    }
    sum = double(two)/double(len) * fu * ou * 100;  //强制转换为双浮点型
    printf("%.2f%\n", sum);

    return 0;
}

```

## 四、反思总结

题目难度不大，但是要注意最后输出两位小数，计算是不能用整型，需要强制转换一下数据类型。

# PTA团队天梯赛║L1-018 **大笨钟**

## 一、题目要求

微博上有个自称“大笨钟V”的家伙，每天敲钟催促码农们爱惜身体早点睡觉。不过由于笨钟自己作息也不是很规律，所以敲钟并不定时。一般敲钟的点数是根据敲钟时间而定的，如果正好在某个整点敲，那么“当”数就等于那个整点数；如果过了整点，就敲下一个整点数。另外，虽然一天有24小时，钟却是只在后半天敲1~12下。例如在23:00敲钟，就是“当当当当当当当当当当当”，而到了23:01就会是“当当当当当当当当当当当当”。在午夜00:00到中午12:00期间（端点时间包括在内），笨钟是不敲的。

下面就请你写个程序，根据当前时间替大笨钟敲钟。

### 输入格式：

输入第一行按照`hh:mm`的格式给出当前时间。其中`hh`是小时，在00到23之间；`mm`是分钟，在00到59之间。

### 输出格式：

根据当前时间替大笨钟敲钟，即在一行中输出相应数量个`Dang`。如果不是敲钟期，则输出：

```
Only hh:mm.  Too early to Dang.
```

其中`hh:mm`是输入的时间。

### 输入样例1：

```in
19:05
```

### 输出样例1：

```out
DangDangDangDangDangDangDangDang
```

### 输入样例2：

```
07:05
```

### 输出样例2：

```out
Only 07:05.  Too early to Dang.
```

## 二、解题思路

题目难度不大，读清楚题意后只需要注意在 `00:00` 和 `24:00` 这个临界点的时候不敲钟，其他分别用两个整型存储输入时间的小时与分钟部分，判断只有小时介于 `13~23` 这个区间才输出 **Dang**，再判断如果分钟不等于零，记录 **Dang** 的计数器要加一即可。

## 三、代码

```c++
#include <iostream>
#include <stdio.h>
#include <cstring>
using namespace std;

int main()
{
    int h, m, a;
    scanf("%d:%d",&h,&m);
    if(h > 12 && h < 24)
    {
        if(m != 0)
        {
            a = h - 11;
        }
        else a = h - 12;
        for(int i=0; i<a; i++)
        {
            cout << "Dang";
        }
    }
    else printf("Only %02d:%02d.  Too early to Dang.",h,m);
    cout << endl;

    return 0;
}

```

## 四、反思总结

在不敲钟的时间段内输出时，要控制都是两位显示，各位数字前面要有0，这样才符合输出规范。

# PTA团队天梯赛║L1-019 **谁先倒**

## 一、题目要求

划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就输了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。

下面给出甲、乙两人的酒量（最多能喝多少杯不倒）和划拳记录，请你判断两个人谁先倒。

### 输入格式：

输入第一行先后给出甲、乙两人的酒量（不超过100的非负整数），以空格分隔。下一行给出一个正整数`N`（≤100），随后`N`行，每行给出一轮划拳的记录，格式为：

```
甲喊 甲划 乙喊 乙划
```

其中`喊`是喊出的数字，`划`是划出的数字，均为不超过100的正整数（两只手一起划）。

### 输出格式：

在第一行中输出先倒下的那个人：`A`代表甲，`B`代表乙。第二行中输出没倒的那个人喝了多少杯。题目保证有一个人倒下。注意程序处理到有人倒下就终止，后面的数据不必处理。

### 输入样例：

```in
1 1
6
8 10 9 12
5 10 5 10
3 8 5 12
12 18 1 13
4 16 12 15
15 1 1 16
```

### 输出样例：

```out
A
1
```

## 二、解题思路

用两个变量存储甲乙的酒量，甲乙再分别用两个变量存储为喊和划的数字，循环 **N** 次，判断两人喊的数字之和与谁划的数字相同，则该人酒量数字减一，当酒量数字小于 **0** 时break，该人倒下输出名字，另一个人没倒的喝了多少杯可以用另一个人的酒量减去他剩余酒量。

## 三、代码

```c++
#include<iostream>

using namespace std;

int main()
{	
	int A,B;	//甲乙酒量
	cin >> A >> B;
	int a = A, b = B;	//a和b用来记录A与B何时倒 
	int N;
	int a1 = 0, a2 = 0, b1 = 0, b2 = 0;	//甲喊 甲划 乙喊 乙划 
	cin >> N;
	while(N--)
	{
		cin >> a1 >> a2 >> b1 >> b2; 
		if((a2 == a1+b1)&&(a2 != b2))	//A输掉一轮
		{
			a--;
		}
		if((b2 == a1+b1)&&(a2 != b2))	//B输掉一轮
		{ 
			b--;
		}
		if(a<0)	//A倒下
		{ 
			cout << "A" << endl << B-b;
			break;
		}
		if(b<0)	//B倒下
		{ 
			cout << "B" << endl << A-a;
			break;
		}	
	} 	
    return 0;
}
```

## 四、反思总结

题目总体使用简单的 ***if*** 条件判断即可完成主要功能，逻辑清晰后代码并不难。

# PTA团队天梯赛║L1-020 **帅到没朋友**

## 一、题目要求

当芸芸众生忙着在朋友圈中发照片的时候，总有一些人因为太帅而没有朋友。本题就要求你找出那些帅到没有朋友的人。

### 输入格式：

输入第一行给出一个正整数`N`（≤100），是已知朋友圈的个数；随后`N`行，每行首先给出一个正整数`K`（≤1000），为朋友圈中的人数，然后列出一个朋友圈内的所有人——为方便起见，每人对应一个ID号，为5位数字（从00000到99999），ID间以空格分隔；之后给出一个正整数`M`（≤10000），为待查询的人数；随后一行中列出`M`个待查询的ID，以空格分隔。

注意：没有朋友的人可以是根本没安装“朋友圈”，也可以是只有自己一个人在朋友圈的人。虽然有个别自恋狂会自己把自己反复加进朋友圈，但题目保证所有`K`超过1的朋友圈里都至少有2个不同的人。

### 输出格式：

按输入的顺序输出那些帅到没朋友的人。ID间用1个空格分隔，行的首尾不得有多余空格。如果没有人太帅，则输出`No one is handsome`。

注意：同一个人可以被查询多次，但只输出一次。

### 输入样例1：

```in
3
3 11111 22222 55555
2 33333 44444
4 55555 66666 99999 77777
8
55555 44444 10000 88888 22222 11111 23333 88888
```

### 输出样例1：

```out
10000 88888 23333
```

### 输入样例2：

```
3
3 11111 22222 55555
2 33333 44444
4 55555 66666 99999 77777
4
55555 44444 22222 11111
```

### 输出样例2：

```out
No one is handsome
```

## 二、解题思路

用一个大小为100000的整型数组存放朋友圈的人，将输入的ID作为下标，初始值均为0。检测如果朋友圈的人数大于一，就将该朋友圈内所有人ID下标的数字置为1。设置一个sum作为没朋友的总人数，检测是否帅的没朋友时，就检测该ID下标对应的数组元素是否为0，若是，则输出该ID，并且sum++。最后判断sum是否为0，若是，则证明没有帅到没朋友的人，输出 `No one is handsome` 。

## 三、代码

```cpp
#include <iostream>
#include <stdio.h>

using namespace std;

int main()
{

    int p[100000] = {0};
    int n, k, m, K;
    cin >> n;
    for(int i=0; i<n; i++)
    {
        cin >> k;
        for(int j=0; j<k; j++)
        {
            cin >> m;
            if(k > 1) p[m] = 1; //将有朋友的人做标记
        }
    }
    int sum = 0;
    cin >> K;
    for(int i=0; i<K; i++)
    {
        cin >> m;
        if(p[m] == 0)
        {
            if(sum != 0) cout << " ";
            printf("%05d", m);  //保证输出格式正确
            p[m] = -1;  //避免重复
            sum += 1;
        }
    }
    if(sum == 0)
        cout << "No one is handsome";
    cout << endl;


    return 0;
}

```

## 四、反思总结

第一次提交未得满分，发现是在输出时未控制格式，遇到诸如 `00038` 这样的ID会输出为 `38` ,后改进用*printf()* ，成功满分通过。

# PTA团队天梯赛║L1-022 **奇偶分家**

## 一、题目要求

给定`N`个正整数，请统计奇数和偶数各有多少个？

### 输入格式：

输入第一行给出一个正整`N`（≤1000）；第2行给出`N`个非负整数，以空格分隔。

### 输出格式：

在一行中先后输出奇数的个数、偶数的个数。中间以1个空格分隔。

### 输入样例：

```in
9
88 74 101 26 15 0 34 22 77
```

### 输出样例：

```out
3 6
```

## 二、解题思路

循环遍历中用 ***if*** 语句判断输入数字后对2取模运算，若为 *0* 则偶数加一，否则奇数加一

## 三、代码

```c++
#include <iostream>

using namespace std;

int main()
{
    int n, m;
    int ou = 0;
    int ji = 0;
    cin >> n;
    for(int i=0; i<n; i++)
    {
        cin >> m;
        if(m % 2 == 0)
            ou++;
        else ji++;
    }
    cout << ji << " " << ou << endl;

    return 0;
}

```

## 四、反思总结

题目较为简单，注意细心就好。

# PTA团队天梯赛║L1-023  **输出GPLT**

## 一、题目要求

给定一个长度不超过10000的、仅由英文字母构成的字符串。请将字符重新调整顺序，按`GPLTGPLT....`这样的顺序输出，并忽略其它字符。当然，四种字符（不区分大小写）的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按`GPLT`的顺序打印，直到所有字符都被输出。

### 输入格式：

输入在一行中给出一个长度不超过10000的、仅由英文字母构成的非空字符串。

### 输出格式：

在一行中按题目要求输出排序后的字符串。题目保证输出非空。

### 输入样例：

```in
pcTclnGloRgLrtLhgljkLhGFauPewSKgt
```

### 输出样例：

```out
GPLTGPLTGLTGLGLL
```

## 二、解题思路

先将输入的字符串全部转换为大写字母，然后对于GPLT四个字母计数，将每个字母出现的次数存放在a[4]中，然后按照顺序输出 `GPLT` ，每输出一个字母，该字母对应的计数减一，直到减为0。

## 三、代码

```cpp
#include <iostream>
#include <cctype>
#include <cstring>
using namespace std;

int main()
{
    int a[4] = {0};   //存放GPLT出现次数
    string s;
    cin >> s;
    for(int i=0; i<s.length(); i++) //将字符串全部转化为大写字母，并计数
    {
        s[i] = toupper(s[i]);
        if(s[i] == 'G') a[0]++;
        else if(s[i] == 'P') a[1]++;
        else if(s[i] == 'L') a[2]++;
        else if(s[i] == 'T') a[3]++;
    }

    //输出
    while(a[0]!=0 || a[1]!=0 || a[2]!=0 || a[3]!=0)
    {
        for(int i=0; i<4; i++)
        {
            if(a[i] != 0)
        {
            a[i]--;
            if(i == 0) cout << "G";
            else if(i == 1) cout << "P";
            else if(i == 2) cout << "L";
            else if(i == 3) cout << "T";
        }
        }
    }
    cout << endl;

    return 0;
}

```

## 四、反思总结

利用了转换大写字母的函数 *toupper()* ，包含在头文件 `<cctype>` 中。

# PTA团队天梯赛║L1-024 **后天**

## 一、题目要

如果今天是星期三，后天就是星期五；如果今天是星期六，后天就是星期一。我们用数字1到7对应星期一到星期日。给定某一天，请你输出那天的“后天”是星期几。

### 输入格式：

输入第一行给出一个正整数`D`（1 ≤ `D` ≤ 7），代表星期里的某一天。

### 输出格式：

在一行中输出`D`天的后天是星期几。

### 输入样例：

```in
3
```

### 输出样例：

```out
5
```

## 二、解题思路

创建一个数组存放1-7的数字，为了使数组与现实数字保持一致，数组首位[0]存放0，接着输入数字，只需要将数字加 **2** 然后对 **7** 取模运算的结果作为数组下标，输出该位置的数字即可。

## 三、代码

```cpp
#include <iostream>

using namespace std;

int main() 
{
    int a[8] = {0,1,2,3,4,5,6,7};
    int n;
    cin >> n;
    if(n == 5) 
        cout << 7 << endl;
    else
        cout << a[(n+2) % 7] << endl;
    
    return 0;
}
```

## 四、反思总结

第一次提交未获得满分，在输入5的时候会输出0，没有考虑到这种情况，加一个判断条件单独对5做处理解决问题。

# PTA团队天梯赛║L1-025 **正整数A+B** 

## 一、题目要求

题的目标很简单，就是求两个正整数`A`和`B`的和，其中`A`和`B`都在区间[1,1000]。稍微有点麻烦的是，输入并不保证是两个正整数。

### 输入格式：

输入在一行给出`A`和`B`，其间以空格分开。问题是`A`和`B`不一定是满足要求的正整数，有时候可能是超出范围的数字、负数、带小数点的实数、甚至是一堆乱码。

注意：我们把输入中出现的第1个空格认为是`A`和`B`的分隔。题目保证至少存在一个空格，并且`B`不是一个空字符串。

### 输出格式：

如果输入的确是两个正整数，则按格式`A + B = 和`输出。如果某个输入不合要求，则在相应位置输出`?`，显然此时和也是`?`。

### 输入样例1：

```in
123 456
```

### 输出样例1：

```out
123 + 456 = 579
```

### 输入样例2：

```
22. 18
```

### 输出样例2：

```
? + 18 = ?
```

### 输入样例3：

```
-100 blabla bla...33
```

### 输出样例3：

```
? + ? = ?
```

## 二、解题思路

创建一个函数 *isint()* ，用于判断输入的是否为正整数，逐个字符判断是否为 `0~9` 之间的字符，一旦有一个字符不符合，返回值为0，否则返回值为1。在主函数中，将 *isint()* 的返回值赋给flag，在输出时，若flag为0则输出 `?` ，结果也输出 `?` 。

## 三、代码

```cpp
//v1.0 得分11分 测试点1、3未通过
#include <iostream>
#include <cstring>
#include <stdlib.h>

using namespace std;

int isint(string s) //判断是否为整数
{
    bool k = 1;
    for(int i=0; i<s.length(); i++)
    {
        if(s[i]<'0' || s[i]>'9')
        {
            k = 0;
        }
    }
    if(k) return 1;
    else return 0;
}
int inrange(string s)   //判断是否在取值范围内
{
    bool k = 1;
    if(atoi(s.c_str()) < 1 || atoi(s.c_str()) > 1000)
    {
        k = 0;
    }
    if(k) return 1;
    else return 0;


}
int main()
{

    string a, b;
    cin >> a >> b;
    bool flag1 = isint(a);
    bool flag2 = isint(b);
    flag1 = inrange(a);
    flag2 = inrange(b);
    if(flag1) cout << a;
    else cout << "?";
    cout << " + ";
    if(flag2) cout << b;
    else cout << "?";
    cout << " = ";
    if(flag1 && flag2) cout << atoi(a.c_str())+atoi(b.c_str());
    else cout << "?";
    cout << endl;


    return 0;
}

```

## 四、反思总结

题目问题很大，现在正在思考第二版如何改进，寻找自己代码缺漏。

```

```



---

# PTA团队天梯赛║L1-027 **出租**

## 一、题目要求

下面是新浪微博上曾经很火的一张图：

![image-20210317102335679](C:\Users\79485\AppData\Roaming\Typora\typora-user-images\image-20210317102335679.png)

一时间网上一片求救声，急问这个怎么破。其实这段代码很简单，`index`数组就是`arr`数组的下标，`index[0]=2` 对应 `arr[2]=1`，`index[1]=0` 对应 `arr[0]=8`，`index[2]=3` 对应 `arr[3]=0`，以此类推…… 很容易得到电话号码是`18013820100`。

本题要求你编写一个程序，为任何一个电话号码生成这段代码 —— 事实上，只要生成最前面两行就可以了，后面内容是不变的。

### 输入格式：

输入在一行中给出一个由11位数字组成的手机号码。

### 输出格式：

为输入的号码生成代码的前两行，其中`arr`中的数字必须按递减顺序给出。

### 输入样例：

```in
18013820100
```

### 输出样例：

```out
int[] arr = new int[]{8,3,2,1,0};
int[] index = new int[]{3,0,4,3,1,0,2,4,3,4,4};
```

## 二、解题思路

创建一个整型数组a[10]存放 `0~9` 在号码中出现的次数，写入字符串，将每一位上的字符转为数字后直接作为数组a的下标，让该位置上数量加一，统计出每个数字的出现次数。新建数组arr[10]，将数组a中非零的元素下标降序写入arr数组，输出。然后挨个比对号码每一位上的数字与arr数组中的数字，若匹配则输出下标。

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int a[10]={0};
    string s;
    cin >> s;
    for(int i=0; i<11; i++)
    {
        a[s[i]-'0']++;
    }
    int arr[10], num = 0;
    for(int i=9; i>=0; i--)
    {
        if(a[i])
        {
            arr[num] = i;
            num++;
        }
    }
    cout << "int[] arr = new int[]{";
    for(int i=0; i<num; i++)
    {
        cout << arr[i];
        if(i<num-1) cout << ",";
    }
    cout << "};" << endl << "int[] index = new int[]{";
    for(int i=0; i<11; i++)
    {
        for(int j=0; j<num; j++)
        {
            if(s[i]-'0'==arr[j]) cout << j;
        }
        if(i<10) cout << ",";
    }
    cout << "};" << endl;

    return 0;
}

```

## 四、反思总结

在比较字符串 s 每一位与数组 arr 是否匹配时，忘记将字符转化为整型数，导致结果出错，谨记在比较时，两边的数据类型是否相同？

---

# PTA团队天梯赛║L1-030 一帮一

## 一、题目要求

“一帮一学习小组”是中小学中常见的学习组织方式，老师把学习成绩靠前的学生跟学习成绩靠后的学生排在一组。本题就请你编写程序帮助老师自动完成这个分配工作，即在得到全班学生的排名后，在当前尚未分组的学生中，将名次最靠前的学生与名次最靠后的**异性**学生分为一组。

### 输入格式：

输入第一行给出正偶数`N`（≤50），即全班学生的人数。此后`N`行，按照名次从高到低的顺序给出每个学生的性别（0代表女生，1代表男生）和姓名（不超过8个英文字母的非空字符串），其间以1个空格分隔。这里保证本班男女比例是1:1，并且没有并列名次。

### 输出格式：

每行输出一组两个学生的姓名，其间以1个空格分隔。名次高的学生在前，名次低的学生在后。小组的输出顺序按照前面学生的名次从高到低排列。

### 输入样例：

```in
8
0 Amy
1 Tom
1 Bill
0 Cindy
0 Maya
1 John
1 Jack
0 Linda
```

### 输出样例：

```out
Amy Jack
Tom Linda
Bill Maya
Cindy John
```

## 二、解题思路

使用一个结构体储存学生信息，一个用 0 和 1 代表学生性别，一个用字符串存储学生姓名，用一个结构体数组按顺序存储学生，用整型数组 `visit` 标记未组队的学生为 0，已组队的学生为1，然后循环从 0 到 n/2 遍历学生，将其与后半部分学生进行比较，若性别不同则输出两个学生姓名，排名靠前的在前，并将其 `visit` 置为1代表已将组好队。若在循环中碰到 `visit` 为 1 的，则 break。

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

struct stu
{
    int sex;
    string name;
};

int main ()
{
    stu s[50];
    int visit[50]={0};
    int n;
    cin >> n;
    for(int i=0; i<n; i++)
    {
        cin >> s[i].sex >> s[i].name;
    }
    for(int i=0; i<n; i++)
    {
        if(visit[i] == 0)
        {
            for(int j=n-1; j>=0; j--)
            {
                if(s[i].sex != s[j].sex && visit[j] == 0)
                {
                    cout << s[i].name << " " << s[j].name << endl;
                    visit[i] = 1;
                    visit[j] = 1;
                    break;
                }
            }
        }
    }

    return 0;
}

```

## 四、反思总结

结构体大括号最后要记得分号！！

---

# PTA团队天梯赛║L1-031 **到底是不是太胖了**

## 一、题目要求

据说一个人的标准体重应该是其身高（单位：厘米）减去100、再乘以0.9所得到的公斤数。真实体重与标准体重误差在10%以内都是完美身材（即 | 真实体重 − 标准体重 | < 标准体重×10%）。已知市斤是公斤的两倍。现给定一群人的身高和实际体重，请你告诉他们是否太胖或太瘦了。

### 输入格式：

输入第一行给出一个正整数`N`（≤ 20）。随后`N`行，每行给出两个整数，分别是一个人的身高`H`（120 < `H` < 200；单位：厘米）和真实体重`W`（50 < `W` ≤ 300；单位：市斤），其间以空格分隔。

### 输出格式：

为每个人输出一行结论：如果是完美身材，输出`You are wan mei!`；如果太胖了，输出`You are tai pang le!`；否则输出`You are tai shou le!`。

### 输入样例：

```in
3
169 136
150 81
178 155
```

### 输出样例：

```out
You are wan mei!
You are tai shou le!
You are tai pang le!
```

## 二、解题思路

根据题目中的公式按个判断，用 if 语句控制不同情况的输出即可

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n, h, w;
    float nw;
    cin >> n;
    while(n--)
    {
        cin >> h >> w;
        nw = ((h-100) * 0.9) * 2;   //标准体重的市斤数
        if(abs(w-nw) < nw*0.1)
        {
            cout << "You are wan mei!" << endl;
        }
        else if(w-nw > 0) cout << "You are tai pang le!" << endl;
        else cout << "You are tai shou le!" << endl;
    }
    
    return 0;
}
```

## 四、反思总结

取整型绝对值函数从 **abs()**

---

# PTA团队天梯赛║L1-032 **Left-pad**

## 一、题目要求

根据新浪微博上的消息，有一位开发者不满NPM（Node Package Manager）的做法，收回了自己的开源代码，其中包括一个叫left-pad的模块，就是这个模块把javascript里面的React/Babel干瘫痪了。这是个什么样的模块？就是在字符串前填充一些东西到一定的长度。例如用`*`去填充字符串`GPLT`，使之长度为10，调用left-pad的结果就应该是`******GPLT`。Node社区曾经对left-pad紧急发布了一个替代，被严重吐槽。下面就请你来实现一下这个模块。

### 输入格式：

输入在第一行给出一个正整数`N`（≤104）和一个字符，分别是填充结果字符串的长度和用于填充的字符，中间以1个空格分开。第二行给出原始的非空字符串，以回车结束。

### 输出格式：

在一行中输出结果字符串。

### 输入样例1：

```in
15 _
I love GPLT
```

### 输出样例1：

```out
____I love GPLT
```

### 输入样例2：

```
4 *
this is a sample for cut
```

### 输出样例2：

```out
 cut
```

## 二、解题思路

先比较输入字符串长度与输出字符数的大小，若字符串长度大于输出字符，则从 `字符串长度-输出字符数`处开始输出直至字符串结束，若字符串长度小于输出字符则先输出 `输出字符数-字符串长度` 个符号再输出字符串。

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    string s;
    int num, dif;
    char c;
    cin >> num >> c;
    getchar();
    getline(cin,s);
    if(s.length()>num)
    {
        dif = s.length()-num;
        for(int i=dif; i<s.length(); i++)
        {
            cout << s[i];
        }
    }
    else
    {
        dif = num-s.length();
        for(int i=0; i<dif; i++)
        {
            cout << c;
        }
        cout << s;
    }
    cout << endl;

    return 0;
}

```

## 四、反思总结

在输入字符串时 `cin` 输入流遇到空字符会结束，现用getchar()清除缓冲区，利用getline()写入直到遇到换行符结束。

---

# PTA团队天梯赛║L1-033 **出生年**

## 一、题目要求

![355](https://images.ptausercontent.com/355)

以上是新浪微博中一奇葩贴：“我出生于1988年，直到25岁才遇到4个数字都不相同的年份。”也就是说，直到2013年才达到“4个数字都不相同”的要求。本题请你根据要求，自动填充“我出生于`y`年，直到`x`岁才遇到`n`个数字都不相同的年份”这句话。

### 输入格式：

输入在一行中给出出生年份`y`和目标年份中不同数字的个数`n`，其中`y`在[1, 3000]之间，`n`可以是2、或3、或4。注意不足4位的年份要在前面补零，例如公元1年被认为是0001年，有2个不同的数字0和1。

### 输出格式：

根据输入，输出`x`和能达到要求的年份。数字间以1个空格分隔，行首尾不得有多余空格。年份要按4位输出。注意：所谓“`n`个数字都不相同”是指不同的数字正好是`n`个。如“2013”被视为满足“4位数字都不同”的条件，但不被视为满足2位或3位数字不同的条件。

### 输入样例1：

```in
1988 4
```

### 输出样例1：

```out
25 2013
```

### 输入样例2：

```
1 2
```

### 输出样例2：

```out
0 0001
```

## 二、解题思路

先将输入的整型转换为字符串，并在不足四位的数前面补零，然后用一个数组 a[10] 存储 0~9 在年份中出现的次数，之后从出生年份循环判断 a 中非零元素个数，若与输入的要求不同数字的个数相同，则输出年龄与该年份；若不同，则年龄与年份自加。

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

bool judge(int str, int n)
{
    string s = to_string(str);
    while(s.length()<4)
    {
        s = "0" + s;
    }
    int count = 0;
    int a[10] = {0};
    for(int i=0; i<s.length(); i++)
    {
        a[s[i]-'0']++;
    }
    for(int i:a)
    {
        if(i!=0)    count++;
    }
    if(count==n) return 1;
    else return 0;
}

int main ()
{
    int year;
    int n, old = 0;
    cin >> year >> n;
    while(!judge(year,n))
    {
        old++;
        year++;
    }
    printf("%d %04d",old,year);
    
    return 0;
}

```

## 四、反思总结

最后要注意控制输出的时候同样年份不足四位的前面要补全 0。

同时贴上网上一个利用 `set` 容器实现的方法，更加高效简单

```cpp
#include<iostream>
#include<set>//set容器不允许重复 
#include<algorithm> 

using namespace std;

int main()
{
	int y,n;
	cin>>y>>n;
	set<int> set;
	for(int i=y;i<y+130;i++)
	{//假设上限为130,能活到130岁 

		int q=i/1000;//千位	 
		int b=i/100%10;//百位	 
		int s=i/10%10;//十位	 
		int g=i%10;//个位
		set.insert(g);
		set.insert(s);
		set.insert(b);
		set.insert(q);
		if(set.size()==n)
		{//满足条件时退出 
			printf("%d %04d\n",i-y,i);
			break;			
		}
		set.clear(); //清空容器,方便下一次数据读入 
	}
	return 0;
}

```



---

# PTA团队天梯赛║L1-034 点赞

## 一、题目要求

微博上有个“点赞”功能，你可以为你喜欢的博文点个赞表示支持。每篇博文都有一些刻画其特性的标签，而你点赞的博文的类型，也间接刻画了你的特性。本题就要求你写个程序，通过统计一个人点赞的纪录，分析这个人的特性。

### 输入格式：

输入在第一行给出一个正整数*N*（≤1000），是该用户点赞的博文数量。随后*N*行，每行给出一篇被其点赞的博文的特性描述，格式为“*K* *F*1⋯*F**K*”，其中1≤*K*≤10，*F**i*（*i*=1,⋯,*K*）是特性标签的编号，我们将所有特性标签从1到1000编号。数字间以空格分隔。

### 输出格式：

统计所有被点赞的博文中最常出现的那个特性标签，在一行中输出它的编号和出现次数，数字间隔1个空格。如果有并列，则输出编号最大的那个。

### 输入样例：

```in
4
3 889 233 2
5 100 3 233 2 73
4 3 73 889 2
2 233 123
```

### 输出样例：

```out
233 3
```

## 二、解题思路

用一个大小为1000的整型数组存放标签出现次数，最后输出数组中数字最大的下标+1，以及存放的出现次数，找数组中最大数字时降序比较，保证并列时输出编号最大的。

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int a[1000]={0};
    int n, m, label;
    cin >> n;
    while(n--)
    {
        cin >> m;
        while(m--)
        {
            cin >> label;
            a[label-1]++;
        }
    }
    int i, max = 999;
    for(i=998; i>=0; i--)
    {
        if(a[i]>a[max])
        {
            max = i;
        }
    }
    cout << max+1 << " " << a[max] << endl;

    return 0;
}

```

## 四、反思总结

题目整体难度不大，注意输出时标签与数组的索引相差一。

---

# PTA团队天梯赛║L1-035 **情人节**

## 一、题目要求

![img](https://images.ptausercontent.com/356)

以上是朋友圈中一奇葩贴：“2月14情人节了，我决定造福大家。第2个赞和第14个赞的，我介绍你俩认识…………咱三吃饭…你俩请…”。现给出此贴下点赞的朋友名单，请你找出那两位要请客的倒霉蛋。

### 输入格式：

输入按照点赞的先后顺序给出不知道多少个点赞的人名，每个人名占一行，为不超过10个英文字母的非空单词，以回车结束。一个英文句点`.`标志输入的结束，这个符号不算在点赞名单里。

### 输出格式：

根据点赞情况在一行中输出结论：若存在第2个人A和第14个人B，则输出“A and B are inviting you to dinner...”；若只有A没有B，则输出“A is the only one for you...”；若连A都没有，则输出“Momo... No one is for you ...”。

### 输入样例1：

```in
GaoXZh
Magi
Einst
Quark
LaoLao
FatMouse
ZhaShen
fantacy
latesum
SenSen
QuanQuan
whatever
whenever
Potaty
hahaha
.
```

### 输出样例1：

```out
Magi and Potaty are inviting you to dinner...
```

### 输入样例2：

```
LaoLao
FatMouse
whoever
.
```

### 输出样例2：

```
FatMouse is the only one for you...
```

### 输入样例3：

```
LaoLao
.
```

### 输出样例3：

```out
Momo... No one is for you ...
```

## 二、解题思路

用 while 语句输入字符串，知道判断输入的字符串第一个字符为 **‘.'** 时，break 跳出循环，初始化两个空字符串，在循环中如果有第二和第十四个输入的字符串，就将其分别赋值给这两个空字符串，最后在循环外判断两字符串是否为空，分情况输出结果。

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    string s;
    string s1=" ", s2=" ";
    int count = 0;
    while(cin>>s)
    {
        if(s[0]=='.')   break;
        count++;
        if(count == 2)  s1 = s;
        if(count == 14) s2 = s;
    }
    if(s1 != " ")
    {
        if(s2 != " ")
            printf("%s and %s are inviting you to dinner...\n",s1.c_str(),s2.c_str());
        else
            printf("%s is the only one for you...\n",s1.c_str());
    }
    else
        printf("Momo... No one is for you ...\n");

    return 0;
}

```

## 四、反思总结

用 *printf()* 输出字符串时，s 为 `string` 类型

**语法**

- const char *c_str();
- c_str()函数返回一个指向正规C字符串的指针, 内容与本string串相同.
- 为了与C兼容，在C中没有string类型，故必须通过string类对象的成员函数c_str()把string对象转换成C中的字符串样式。

需要 s.c_str() 才可以正确输出。

---

# PTA团队天梯赛║L1-037 **A除以B**

## 一、题目要求

真的是简单题哈 —— 给定两个绝对值不超过100的整数*A*和*B*，要求你按照“*A*/*B*=商”的格式输出结果。

### 输入格式：

输入在第一行给出两个整数*A*和*B*（−100≤*A*,*B*≤100），数字间以空格分隔。

### 输出格式：

在一行中输出结果：如果分母是正数，则输出“*A*/*B*=商”；如果分母是负数，则要用括号把分母括起来输出；如果分母为零，则输出的商应为`Error`。输出的商应保留小数点后2位。

### 输入样例1：

```in
-1 2
```

### 输出样例1：

```out
-1/2=-0.50
```

### 输入样例2：

```
1 -3
```

### 输出样例2：

```
1/(-3)=-0.33
```

### 输入样例3：

```
5 0
```

### 输出样例3：

```out
5/0=Error
```

## 二、解题思路

用浮点数进行运算，注意输出格式，判断分母正负与零的情况，控制输出时分子分母为整数形式，商保留两位小数。

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    float a,b,quo;
    cin >> a >> b;
    quo = a/b;
    if(b > 0)
        printf("%.0f/%.0f=%.2f",a,b,quo);
    else if(b == 0)
        printf("%.0f/%.0f=Error",a,b);
    else
        printf("%.0f/(%.0f)=%.2f",a,b,quo);
    cout << endl;

    return 0;
}

```

## 四、反思总结

起初看到题目要求输入的分子分母为整数，就用 `int` 作为分子分母的数据类型，结果发现整型的除法只保留整数部分，商虽然用 `float` 但是依旧数据错误，后将分子分母数据类型也用浮点型，输出时用 ***printf(%.0f)*** 控制不输出小数部分。

---

# PTA团队天梯赛║L1-039 **古风排版**

## 一、题目要求

中国的古人写文字，是从右向左竖向排版的。本题就请你编写程序，把一段文字按古风排版。

### 输入格式：

输入在第一行给出一个正整数*N*（<100），是每一列的字符数。第二行给出一个长度不超过1000的非空字符串，以回车结束。

### 输出格式：

按古风格式排版给定的字符串，每列*N*个字符（除了最后一列可能不足*N*个）。

### 输入样例：

```in
4
This is a test case
```

### 输出样例：

```out
asa T
st ih
e tsi
 ce s
```

## 二、解题思路

利用一个二维字符数组存放字符串比较容易操作与理解，输入行数后就可以根据字符串长度确定输出时的列数，然后从最后一列开始输入字符串的每一个字符，直至字符串结束。最后顺序输出二位字符数组即可。

## 三、代码

```cpp
//v1.0 初始化字符数组
#include <bits/stdc++.h>
using namespace std;

int main()
{
    string s;
    char a[100][100]={' '};	//字符数组不可以这样初始化
    int row, col, k = 0;
    cin >> row;
    getchar();
    getline(cin,s);
    if(s.length()%row == 0)
        col = s.length() / row;
    else
        col = s.length() / row + 1;
    for(int i=col-1; i>=0; i--)
    {
        for(int j=0; j<row; j++)
        {
            a[j][i] = s[k++];
            if(k==s.length()) break;
        }
    }

    for(int i=0; i<row; i++)
    {
        for(int j=0; j<col; j++)
        {
            cout << a[i][j];
        }
        cout << endl;
    }
    cout << endl;

    return 0;
}

```

## 四、反思总结

第一版中错误的使用 a[100] [100] = ' '进行初始化字符数组，导致不能通过测试。

改进后代码如下

```cpp
//v2.0 改进初始化字符数组方式，成功AC
#include <bits/stdc++.h>
using namespace std;

int main()
{
    string s;
    char a[100][100];
    for(int i = 0; i < 100; i++){		//利用循环挨个为字符数组元素赋值
        for(int j = 0; j < 100; j++){
            a[i][j] = ' ';
        }
    }
    int row, col, k = 0;
    cin >> row;
    getchar();
    getline(cin,s);
    if(s.length()%row == 0)
        col = s.length() / row;
    else
        col = s.length() / row + 1;
    for(int i=col-1; i>=0; i--)
    {
        for(int j=0; j<row; j++)
        {
            a[j][i] = s[k++];
            if(k==s.length()) break;
        }
    }

    for(int i=0; i<row; i++)
    {
        for(int j=0; j<col; j++)
        {
            cout << a[i][j];
        }
        cout << endl;
    }

    return 0;
}

```



---

# PTA团队天梯赛║L1-043 **阅览室**

## 一、题目要求

天梯图书阅览室请你编写一个简单的图书借阅统计程序。当读者借书时，管理员输入书号并按下`S`键，程序开始计时；当读者还书时，管理员输入书号并按下`E`键，程序结束计时。书号为不超过1000的正整数。当管理员将0作为书号输入时，表示一天工作结束，你的程序应输出当天的读者借书次数和平均阅读时间。

注意：由于线路偶尔会有故障，可能出现不完整的纪录，即只有`S`没有`E`，或者只有`E`没有`S`的纪录，系统应能自动忽略这种无效纪录。另外，题目保证书号是书的唯一标识，同一本书在任何时间区间内只可能被一位读者借阅。

### 输入格式：

输入在第一行给出一个正整数*N*（≤10），随后给出*N*天的纪录。每天的纪录由若干次借阅操作组成，每次操作占一行，格式为：

`书号`（[1, 1000]内的整数） `键值`（`S`或`E`） `发生时间`（`hh:mm`，其中`hh`是[0,23]内的整数，`mm`是[0, 59]内整数）

每一天的纪录保证按时间递增的顺序给出。

### 输出格式：

对每天的纪录，在一行中输出当天的读者借书次数和平均阅读时间（以分钟为单位的精确到个位的整数时间）。

### 输入样例：

```in
3
1 S 08:10
2 S 08:35
1 E 10:00
2 E 13:16
0 S 17:00
0 S 17:00
3 E 08:10
1 S 08:20
2 S 09:00
1 E 09:20
0 E 17:00
```

### 输出样例：

```out
2 196
0 0
1 60
```

## 二、解题思路

因为有可能会有书未被借出就还书的错误情况，而且要记录平均平均阅读时间，因此用一个结构体存储书籍借出情况 `flag` （0为未借出，1为借出），以及借出时间 `starttime` 。在判断键入时，若书号键入 0 则跳出当日的输入循环，否则判断键值 `S` 时写入借出时间，借书计数加一；判断键值 `E` 时，该书号 `flag` 若为 0 则忽略，若为 1 则将还书时间减去借出时间作为借阅时间加入本日的阅览总时间，并将 `flag` 置为 0。最后计算平均借阅时间，输出借书计数与平均借阅时间即可。

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef struct Book
{
    bool flag;  //0为未被借出，1为借出
    int starttime;  //借出时间
}book;

int gettime(int h, int m)
{
    return h*60 + m;
}

int main()
{
    int n;
    cin >> n;
    Book b[1001];
    double sumtime; //最后要四舍五入取double类型
    int num, h, m, count;  //书号，结束时间的时与分，每日的借书数量
    char c; //键值
    for(int i=0; i<n; i++)
    {
        memset(b,0,sizeof(Book)*1001);  //初始化结构体，新的一天将所有书本状态归零
        sumtime = 0;    //新的一天阅览总时间归零
        count = 0;  //每日借书数量归零
        while(scanf("%d %c %d:%d",&num,&c,&h,&m))
        {
            if(num==0) break;
            if(c == 'S')
            {
                b[num].starttime = gettime(h,m);
                b[num].flag = 1;
            }
            if(c == 'E')
            {
                if(b[num].flag == 1)
                {
                    sumtime += gettime(h,m)-b[num].starttime;
                    b[num].flag = 0;
                    count++;
                }
                else
                    continue;
            }
        }
        if(count == 0)
        {
            printf("0 0\n");
        }
        else
        {
            int averge = round(sumtime/count);
            printf("%d %d\n",count,averge);
        }
        
    }
    
    return 0;
}
```

## 四、反思总结

1. ***void \*memset(void \*s, int c, size_t n)***

   memset:作用是在一段内存块中填充某个给定的值，它对较大的结构体或数组进行清零操作的一种最快方法。

   一定要记住 如果要把一个char a[20]清零, 一定是 memset(a, 0, 20) 
   而不是 memset(a, 20, 0) 

2. 注意本题容易出现 **浮点错误** ，即有可能除数为 0 ，要注意将这一特殊情况分开讨论。
3. 起初部分测试点结果一直差一，是因为整型数据除法计算直接保留整数，为了让结果四舍五入，将数据类型改为 `double` ，然后使用 *round()* 函数实现计算结果四舍五入。

---

# PTA团队天梯赛║L1-046 **整除光棍**

## 一、题目要求

这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由1组成的数字，比如1、11、111、1111等。传说任何一个光棍都能被一个不以5结尾的奇数整除。比如，111111就可以被13整除。 现在，你的程序要读入一个整数`x`，这个整数一定是奇数并且不以5结尾。然后，经过计算，输出两个数字：第一个数字`s`，表示`x`乘以`s`是一个光棍，第二个数字`n`是这个光棍的位数。这样的解当然不是唯一的,题目要求你输出最小的解。

提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除`x`为止。但难点在于，`s`可能是个非常大的数 —— 比如，程序输入31，那么就输出3584229390681和15，因为31乘以3584229390681的结果是111111111111111，一共15个1。

### 输入格式：

输入在一行中给出一个不以5结尾的正奇数`x`（<1000）。

### 输出格式：

在一行中输出相应的最小的`s`和`n`，其间以1个空格分隔。

### 输入样例：

```in
31
```

### 输出样例：

```out
3584229390681 15
```

## 二、解题思路

模拟竖式除法的过程，按位进行除法，用字符数组存放除得的数来解决得到的数会很长的问题

## 三、代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int x;
    scanf("%d",&x);
    char a[10005];
    int l=0;
    int m=1;
    int p=0;
    while(1)
    {
        if(p||m/x)//p非0或者m/x非0
        {
            a[p++]='0'+m/x;//除得的数化为字符存储
        }
        l++;
        m=m%x;
        if(m==0)
        {
            a[p]='\0';
            printf("%s %d\n",a,l);
            break;
        }
        m=m*10+1;
    }
    return 0;
}
```

## 四、反思总结

注意在字符数组最后一位要赋值 `'\n'` 标志字符数组结束，否则输出时会出现乱码问题

---

# PTA团体天梯赛║**L1-049 天梯赛座位分配**

## 一、题目要求

天梯赛每年有大量参赛队员，要保证同一所学校的所有队员都不能相邻，分配座位就成为一件比较麻烦的事情。为此我们制定如下策略：假设某赛场有 N 所学校参赛，第 i 所学校有 M[i] 支队伍，每队 10 位参赛选手。令每校选手排成一列纵队，第 i+1 队的选手排在第 i 队选手之后。从第 1 所学校开始，各校的第 1 位队员顺次入座，然后是各校的第 2 位队员…… 以此类推。如果最后只剩下 1 所学校的队伍还没有分配座位，则需要安排他们的队员隔位就坐。本题就要求你编写程序，自动为各校生成队员的座位号，从 1 开始编号。

### 输入格式：

输入在一行中给出参赛的高校数 N （不超过100的正整数）；第二行给出 N 个不超过10的正整数，其中第 i 个数对应第 i 所高校的参赛队伍数，数字间以空格分隔。

### 输出格式：

从第 1 所高校的第 1 支队伍开始，顺次输出队员的座位号。每队占一行，座位号间以 1 个空格分隔，行首尾不得有多余空格。另外，每所高校的第一行按“#X”输出该校的编号X，从 1 开始。

### 输入样例：

```in
3
3 4 2
```

### 输出样例：

```out
#1
1 4 7 10 13 16 19 22 25 28
31 34 37 40 43 46 49 52 55 58
61 63 65 67 69 71 73 75 77 79
#2
2 5 8 11 14 17 20 23 26 29
32 35 38 41 44 47 50 53 56 59
62 64 66 68 70 72 74 76 78 80
82 84 86 88 90 92 94 96 98 100
#3
3 6 9 12 15 18 21 24 27 30
33 36 39 42 45 48 51 54 57 60
```

## 二、解题思路

让每个学校的学生排成一排，为每个座位安排学生。num[i] 是第 i 个学校的队伍数，id_school[i] 是第 i 个座位上坐的是哪个学校的学生。

每把椅子依次从学生面前走过，如果这个学校还有学生未被安排，则安排座位给学生，安排方案如下：

如果此前一个座位的学生不是本校的，则将该作为安排给此校学生，并标记这把椅子被该校学生坐了；如果此前的一个座位是本校学生，则将此学生安排在后一个座位上，并标记后一个座位被该校学生坐了。

设置 flag 标志，如果所有学生都被安排，则可退出。

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, cnt = 1, num[101] = {0}, id_school[10001] = {0};
    cin >> n;
    vector< vector<int> > v(n+1);
    for(int i=1; i<=n; i++) {
        cin >> num[i];
    }
    while(1) {
        bool flag = 1;
        for(int i=1; i<v.size(); i++) {
            if(v[i].size() < num[i]*10) {
                if(id_school[cnt-1] != i) {
                    id_school[cnt] = i;
                    v[i].push_back(cnt);
                    cnt++;
                }
                else {
                    id_school[cnt+1] = i;
                    v[i].push_back(cnt+1);
                    cnt+=2;
                }
                flag = 0;
            }
        }
        if(flag) break;
    }

    for(int i=1; i<v.size(); i++) {
        printf("#%d\n",i);
        for(int j=0; j<v[i].size(); j++) {
            if(j !=0 && j % 10 != 0) cout << " ";
            if(j !=0 && j % 10 == 0) cout << endl;
            cout << v[i][j];
        }
        cout << endl;
    }

    return 0;
}
```

## 四、反思总结

解题思路参考柳诺大神的想法，以后还要好好琢磨再看这道题目！

---

# PTA团队天梯赛║L1-050 **倒数第N个字符串**

## 一、题目要求

给定一个完全由小写英文字母组成的字符串等差递增序列，该序列中的每个字符串的长度固定为 L，从 L 个 a 开始，以 1 为步长递增。例如当 L 为 3 时，序列为 { aaa, aab, aac, ..., aaz, aba, abb, ..., abz, ..., zzz }。这个序列的倒数第27个字符串就是 zyz。对于任意给定的 L，本题要求你给出对应序列倒数第 N 个字符串。

### 输入格式：

输入在一行中给出两个正整数 L（2 ≤ L ≤ 6）和 N（≤105）。

### 输出格式：

在一行中输出对应序列倒数第 N 个字符串。题目保证这个字符串是存在的。

### 输入样例：

```in
3 7417
```

### 输出样例：

```out
pat
```

## 二、解题思路

该题本质是一道进制转换的题目。将L位数看作L位数字26进制组成的数字，则最后一位数字的十进制表示为 pow(26,L) - 1，倒数第 N 个数字的十进制表示则为 pow(26,L) - N ;

然后将所求的数字转换为26进制即可。还原为26进制时位数不足，则在前面补满 'a' 即可。

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int l, n, num;
    vector<int> v;
    cin >> l >> n;
    num = pow(26,l) - n;
    while(num) {
        v.push_back(num % 26);
        num = num / 26;
    }
    for(int i=0; i<l-v.size(); i++) {
        cout << "a";
    }
    for(int i=v.size()-1; i>=0; i--) {  //v 内的存放顺序是反的，因此倒序输出
        cout << char('a' + v[i]);
    }
    cout << endl;
    
    return 0;
}
```

## 四、反思总结

运用了进制转换的思想，要注意在转换计算时，是倒序输出的。

---

# PTA团体天梯赛║**L1-054 福到了**

## 一、题目要求

“福”字倒着贴，寓意“福到”。不论到底算不算民俗，本题且请你编写程序，把各种汉字倒过来输出。这里要处理的每个汉字是由一个 N × N 的网格组成的，网格中的元素或者为字符 `@` 或者为空格。而倒过来的汉字所用的字符由裁判指定。

### 输入格式：

输入在第一行中给出倒过来的汉字所用的字符、以及网格的规模 N （不超过100的正整数），其间以 1 个空格分隔；随后 N 行，每行给出 N 个字符，或者为 `@` 或者为空格。

### 输出格式：

输出倒置的网格，如样例所示。但是，如果这个字正过来倒过去是一样的，就先输出`bu yong dao le`，然后再用输入指定的字符将其输出。

### 输入样例 1：

```in
$ 9
 @  @@@@@
@@@  @@@ 
 @   @ @ 
@@@  @@@ 
@@@ @@@@@
@@@ @ @ @
@@@ @@@@@
 @  @ @ @
 @  @@@@@
```

### 输出样例 1：

```out
$$$$$  $ 
$ $ $  $ 
$$$$$ $$$
$ $ $ $$$
$$$$$ $$$
 $$$  $$$
 $ $   $ 
 $$$  $$$
$$$$$  $ 
```

### 输入样例 2：

```in
& 3
@@@
 @ 
@@@
```

### 输出样例 2：

```out
bu yong dao le
&&&
 & 
&&&
```

## 二、解题思路

设置 flag 来判断是否倒过来和原来相同，然后输出时倒序输出即可。

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    char c;
    cin >> c;
    int n;
    cin >> n;
    getchar();
    vector<string> v(n);
    int flag = 0;
    for(int i=0; i<n; i++) {
        getline(cin,v[i]);
    }
    for(int i=0; i<n; i++) {
        for(int j=0; j<n; j++) {
            if(v[i][j] != v[n-1-i][n-1-j])
                flag = 1;
        }
    }
    if(flag == 0)
        cout << "bu yong dao le" << endl;
    for(int i=0; i<n; i++) {
        for(int j=0; j<n; j++) {
            if(v[n-1-i][n-1-j] == '@')
                cout << c;
            else cout << ' ';
        }
        cout << endl;
    }
    
    return 0;
}
```

## 四、反思总结

注意在输入 c 和 n 后，要加一个 *getchar()* 来吸收掉换行，否则程序输出会出错。

# PTA团队天梯赛║L1-0**56 猜数字**

## 一、解题思路

一群人坐在一起，每人猜一个 100 以内的数，谁的数字最接近大家平均数的一半就赢。本题就要求你找出其中的赢家。

### 输入格式：

输入在第一行给出一个正整数N（≤104）。随后 N 行，每行给出一个玩家的名字（由不超过8个英文字母组成的字符串）和其猜的正整数（≤ 100）。

### 输出格式：

在一行中顺序输出：大家平均数的一半（只输出整数部分）、赢家的名字，其间以空格分隔。题目保证赢家是唯一的。

### 输入样例：

```in
7
Bob 35
Amy 28
James 98
Alice 11
Jack 45
Smith 33
Chris 62
```

### 输出样例：

```out
22 Amy
```

## 二、解题思路

用一个结构体存储每个人的名字与数字，然后用 min 存储结构体数组中与平均数一半差值最小的下标，通过取绝对值比较差值的方法更新 min ，最后输出结果即可。

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

struct hm {
    string name;
    int num;
};

int main() {
    vector<hm> v;
    int n, sum = 0;
    hm temp;
    cin >> n;
    for(int i=0; i<n; i++) {
        cin >> temp.name >> temp.num;
        v.push_back(temp);
        sum += temp.num;
    }
    float ave = sum / n / 2;
    int min = 0;
    for(int i=0; i<n; i++) {
        if (abs(v[i].num - ave) < abs(v[min].num - ave)) {
            min = i;
        }
    }
    printf("%.0f %s\n",ave,v[min].name.c_str());

    return 0;
}
```

## 四、反思总结

使用 printf() 输出时，由于 C 语言中 string 类的问题，需要使用函数 c_str() 将 C++ 的 string 类型字符串转化为 C 语言中的字符串类型。

---

# PTA团队天梯赛║L1-0**58 6翻了**

## 一、题目要求

666”是一种网络用语，大概是表示某人很厉害、我们很佩服的意思。最近又衍生出另一个数字“9”，意思是“6翻了”，实在太厉害的意思。如果你以为这就是厉害的最高境界，那就错啦 —— 目前的最高境界是数字“27”，因为这是 3 个 “9”！

本题就请你编写程序，将那些过时的、只会用一连串“6666……6”表达仰慕的句子，翻译成最新的高级表达。

### 输入格式：

输入在一行中给出一句话，即一个非空字符串，由不超过 1000 个英文字母、数字和空格组成，以回车结束。

### 输出格式：

从左到右扫描输入的句子：如果句子中有超过 3 个连续的 6，则将这串连续的 6 替换成 9；但如果有超过 9 个连续的 6，则将这串连续的 6 替换成 27。其他内容不受影响，原样输出。

### 输入样例：

```in
it is so 666 really 6666 what else can I say 6666666666
```

### 输出样例：

```out
it is so 666 really 9 what else can I say 27
```

## 二、解题思路

设置一个 cnt 用来记录遍历字符串时遇到的 ‘6’ ，若遇到 ‘6’ ，则 cnt++ ；否则，判断 `0<cnt<4` 按照 cnt大小输出 ‘6’ ，`3<cnt<10` 则输出 ’9‘ ，`cnt>9` 则输出 ”27“（以上三步操作结束后均需将 cnt 归零），输出本位上的字符。

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    string s;
    getline(cin,s);
    int cnt = 0;
    for(int i=0; i<s.length(); i++) {
        if(s[i]=='6') {
            cnt++;
        }
        else {
            if(cnt > 9)
                cout << "27";
            else if(cnt > 3)
                cout << '9';
            else {
                while(cnt--)
                    cout << '6';
            }
            cnt = 0;
            cout << s[i];
        }
    }
    if(cnt > 9)
        cout << "27";
    else if(cnt > 3)
        cout << '9';
    else {
        while(cnt--)
            cout << '6';
    }
    cout << endl;

    return 0;
}
```

## 四、反思总结

如果 6 出现在了字符串尾会出现读取不到的错误，分析可能是读到字符串结束符号 `\0` , 所以最后又加了一趟对 cnt 是否为零的判断，保证结束后 cnt 为 0。

---

# PTA团队天梯赛║L1-0**59 敲笨种**

## 一、题目要求

微博上有个自称“大笨钟V”的家伙，每天敲钟催促码农们爱惜身体早点睡觉。为了增加敲钟的趣味性，还会糟改几句古诗词。其糟改的方法为：去网上搜寻压“ong”韵的古诗词，把句尾的三个字换成“敲笨钟”。例如唐代诗人李贺有名句曰：“寻章摘句老雕虫，晓月当帘挂玉弓”，其中“虫”（chong）和“弓”（gong）都压了“ong”韵。于是这句诗就被糟改为“寻章摘句老雕虫，晓月当帘敲笨钟”。

现在给你一大堆古诗词句，要求你写个程序自动将压“ong”韵的句子糟改成“敲笨钟”。

### 输入格式：

输入首先在第一行给出一个不超过 20 的正整数 N。随后 N 行，每行用汉语拼音给出一句古诗词，分上下两半句，用逗号 `,` 分隔，句号 `.` 结尾。相邻两字的拼音之间用一个空格分隔。题目保证每个字的拼音不超过 6 个字符，每行字符的总长度不超过 100，并且下半句诗至少有 3 个字。

### 输出格式：

对每一行诗句，判断其是否压“ong”韵。即上下两句末尾的字都是“ong”结尾。如果是压此韵的，就按题面方法糟改之后输出，输出格式同输入；否则输出 `Skipped`，即跳过此句。

### 输入样例：

```in
5
xun zhang zhai ju lao diao chong, xiao yue dang lian gua yu gong.
tian sheng wo cai bi you yong, qian jin san jin huan fu lai.
xue zhui rou zhi leng wei rong, an xiao chen jing shu wei long.
zuo ye xing chen zuo ye feng, hua lou xi pan gui tang dong.
ren xian gui hua luo, ye jing chun shan kong.
```

### 输出样例：

```out
xun zhang zhai ju lao diao chong, xiao yue dang lian qiao ben zhong.
Skipped
xue zhui rou zhi leng wei rong, an xiao chen jing qiao ben zhong.
Skipped
Skipped
```

## 二、解题思路

检查每一个字符，遇到 `','` 和 `'.'` 时，向前回溯三位判断是否压韵，若不符合则将 flag 置为 0 ，并 break；若都符合，则在 `'.'` 向前回溯三个空格（三个单词），利用 string 里的 *replace()* 方法替换字符串内容。

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    string s;
    int n;
    cin >> n;
    getchar();
    for(int i=0; i<n; i++) {
        getline(cin,s);
        bool flag = 1;
        for(int j=0; j<s.length(); j++) {
            if(s[j] == ',') {
                if(!(s[j-3] == 'o' && s[j-2] == 'n' && s[j-1] == 'g')) {
                    flag = 0;
                    break;
                }
            }
            if(s[j] == '.') {
                if(!(s[j-3] == 'o' && s[j-2] == 'n' && s[j-1] == 'g')) {
                    flag = 0;
                    break;
                }
                else {
                    int m = j;
                    for(int k=0; k<3; m--) {
                        if(s[m] == ' ')
                            k++;
                    }
                    s.replace(m+2,j-m,"qiao ben zhong.");
                }
            }
        }
        if(!flag)   cout << "Skipped" << endl;
        else    cout << s << endl;
    }
    return 0;
}
```

## 四、反思总结

string 里的 *replace()* 方法：

```cpp
#include<iostream>
#include<string>
using namespace std;
int main() {
	{//应用一：string &replace(size_t pos,size_t len,const &str)实现
		string s = "0123456";
		string str = "ABCD";
		s.replace(2, 2, str);//在s的pos=2位置往后len=2字符（“23”）替换为"ABCD"
		cout << s << "\n"; 
	}
	{//应用二：string &replace(size_t pos, size_tlen, const string &str, size_t subpos, size_t sublen)
		//被替换位置(pos往后len长度)，替换位置（subpos往后sublen长度）
		string s = "0123456";
		string str = "ABCD";
		s.replace(2, 2, str, 1, 2);//s在s的pos=2位置往后len=2个字符（“23”）替换为“BC”(str中subpos=1往后两个位置)
		cout << s << "\n";
		
	} 
	{//应用三:string &replace(size_t pos,size_t len,const char* s)  插入C串
		string s = "0123456";
		char str[] = "ABCD";
		s.replace(2, 2, str, 1, 2);s在s的pos=2位置往后len=2个字符（“23”）替换为“BC”(str中subpos=1往后两个位置)
		cout << s << "\n";

	}
	{//应用四：string &replace（size_t pos,size_t len,const char* cch,size_t n）插入C串前n个字符
		string s = "0123456";
		s.replace(2, 2, "ABCD", 2);//在指定位置（pos=2,len=2）插入“ABCD”前两个字符
		cout << s << "\n";
	}
	
	{//应用五：string &replace(size_t pos, size_t len, size_t n, char c)
		string s = "0123456";
		s.replace(2, 2, 5, 'A');//在指定位置（pos=2,len=2）插入5个'A';
		cout << s << "\n";

	}
	{//应用六：（只举一例，其他与size_t操作类似）
		//string &replace(const_iterator first,const_iterator last,const string&str)
		//string &replace(const_iterator first,const_iterator last,const char* cch)
		//string &replace(const_iterator first,const_iterator last,const char* cch,size_t n)
		//string &replace(const_iterator first,const_iterator last,size_t n,char c)
		//需要注意的是迭代器操作中第二个参数不再是len而是位置
		string s = "0123456";
		string str = "ABCD";  
		string::iterator it= s.begin();
		s.replace(it, it+2, str);//s在s的pos=2位置往后len=2个字符（“23”）替换为“BC”(str中subpos=1往后两个位置)
		cout << s << "\n";
	}

	system("pause");
	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190326083320232.png)

# PTA团队天梯赛║L1-0**69 胎压监测**

## 一、题目要求

小轿车中有一个系统随时监测四个车轮的胎压，如果四轮胎压不是很平衡，则可能对行车造成严重的影响。

让我们把四个车轮 —— 左前轮、右前轮、右后轮、左后轮 —— 顺次编号为 1、2、3、4。本题就请你编写一个监测程序，随时监测四轮的胎压，并给出正确的报警信息。报警规则如下：

- 如果所有轮胎的压力值与它们中的最大值误差在一个给定阈值内，并且都不低于系统设定的最低报警胎压，则说明情况正常，不报警；
- 如果存在一个轮胎的压力值与它们中的最大值误差超过了阈值，或者低于系统设定的最低报警胎压，则不仅要报警，而且要给出可能漏气的轮胎的准确位置；
- 如果存在两个或两个以上轮胎的压力值与它们中的最大值误差超过了阈值，或者低于系统设定的最低报警胎压，则报警要求检查所有轮胎。

### 输入格式：

输入在一行中给出 6 个 [0, 400] 范围内的整数，依次为 1~4 号轮胎的胎压、最低报警胎压、以及胎压差的阈值。

### 输出格式：

根据输入的胎压值给出对应信息：

- 如果不用报警，输出 `Normal`；
- 如果有一个轮胎需要报警，输出 `Warning: please check #X!`，其中 `X` 是出问题的轮胎的编号；
- 如果需要检查所有轮胎，输出 `Warning: please check all the tires!`。

### 输入样例 1：

```in
242 251 231 248 230 20
```

### 输出样例 1：

```out
Normal
```

### 输入样例 2：

```in
242 251 232 248 230 10
```

### 输出样例 2：

```out
Warning: please check #3!
```

### 输入样例 3：

```in
240 251 232 248 240 10
```

### 输出样例 3：

```out
Warning: please check all the tires!
```

## 二、解题思路

用一个整型数组存放四个轮胎胎压，下标加一即是对应的轮胎位置，输入时复制一个相同的数组，一个用 *sort()* 排序得到最大胎压 a[3]，然后用 warn 标记出现问题的轮胎数，进行后续的判断得到相应输出。

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int a[4], b[4];
    int min, dif;
    for(int i=0; i<4; i++)
    {
        cin >> a[i];
        b[i] = a[i];
    }
    cin >> min >> dif;
    sort(a,a+4);
    int warn = 0;   //出现问题的轮胎数
    int t;  //一个轮胎出现问题时的位置
    for(int i=0; i<4; i++)
    {
        if(b[i] < min || (a[3]-b[i]) > dif)
        {
            warn++;
            t = i+1;
        }
    }
    if(warn == 1)
    {
        printf("Warning: please check #%d!\n",t);
    }
    else if(warn > 1)
    {
        printf("Warning: please check all the tires!\n");
    }
    else printf("Normal\n");
    
    return 0;
}
```

## 四、反思总结

起初用数组存放轮胎胎压时，直接用 *sort()* 函数打乱了原轮胎位置，导致输出出现问题对轮胎位置时出现错位现象，后用复制一个数组的办法存放原位置解决。

---

# PTA团队天梯赛║L1-070 吃火锅

## 一、题目要求

本题要求你实现一个程序，自动检查你朋友给你发来的信息里有没有 `chi1 huo3 guo1`。

### 输入格式：

输入每行给出一句不超过 80 个字符的、以回车结尾的朋友信息，信息为非空字符串，仅包括字母、数字、空格、可见的半角标点符号。当读到某一行只有一个英文句点 `.` 时，输入结束，此行不算在朋友信息里。

### 输出格式：

首先在一行中输出朋友信息的总条数。然后对朋友的每一行信息，检查其中是否包含 `chi1 huo3 guo1`，并且统计这样厉害的信息有多少条。在第二行中首先输出第一次出现 `chi1 huo3 guo1` 的信息是第几条（从 1 开始计数），然后输出这类信息的总条数，其间以一个空格分隔。题目保证输出的所有数字不超过 100。

如果朋友从头到尾都没提 `chi1 huo3 guo1` 这个关键词，则在第二行输出一个表情 `-_-#`。

### 输入样例 1：

```in
Hello!
are you there?
wantta chi1 huo3 guo1?
that's so li hai le
our story begins from chi1 huo3 guo1 le
.
```

### 输出样例 1：

```out
5
3 2
```

### 输入样例 2：

```in
Hello!
are you there?
wantta qi huo3 guo1 chi1huo3guo1?
that's so li hai le
our story begins from ci1 huo4 guo2 le
.
```

### 输出样例 2：

```out
5
-_-#
```

## 二、解题思路

这是一个字符串匹配问题，可以利用 string 类里的 *find()* 函数查找匹配，用 sum, first, count 分别计数信息总行数，第一次出现匹配字符串的行数以及所有匹配字符串出现的次数。

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int sum = 0, first = -1, count = 0;
    string s;
    while(1)
    {
        getline(cin,s);
        if(s == ".")
        {
            cout << sum << endl;
            break;
        }
        sum++;
        if(s.find("chi1 huo3 guo1") != string::npos)
        {
            count++;
            if(count == 1)
            {
                first = sum;
            }
        }
    }
    if(count != 0)
        printf("%d %d\n",first,count);
    else
        printf("-_-#\n");
    
    return 0;
}
```

## 四、反思总结

查找字符串a是否包含子串b,不是用 strA.find(strB) > 0 而是 strA.find(strB) != string:npos 其中 string:npos是个特殊值，说明查找没有匹配

---

# PTA团队天梯赛║L1-071 前世档案

## 一、题目要求

网络世界中时常会遇到这类滑稽的算命小程序，实现原理很简单，随便设计几个问题，根据玩家对每个问题的回答选择一条判断树中的路径（如下图所示），结论就是路径终点对应的那个结点。![path.jpg](https://images.ptausercontent.com/822292db-6097-418b-a245-02e4a2473560.jpg)

现在我们把结论从左到右顺序编号，编号从 1 开始。这里假设回答都是简单的“是”或“否”，又假设回答“是”对应向左的路径，回答“否”对应向右的路径。给定玩家的一系列回答，请你返回其得到的结论的编号。

### 输入格式：

输入第一行给出两个正整数：*N*（≤30）为玩家做一次测试要回答的问题数量；*M*（≤100）为玩家人数。

随后 *M* 行，每行顺次给出玩家的 *N* 个回答。这里用 `y` 代表“是”，用 `n` 代表“否”。

### 输出格式：

对每个玩家，在一行中输出其对应的结论的编号。

### 输入样例：

```in
3 4
yny
nyy
nyn
yyn
```

### 输出样例：

```out
3
5
6
2
```

## 二、解题思路

转化题目为找数学规律的题目，结论编号可通过每次问题的选择计算得出，令起始的结论编号为1，遇到 ‘y’ 则结论编号不做变化，若遇到 ‘n’，则将结论编号加 2 <sup>n-j</sup> ( j )为第几个问题。

## 三、代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
    int n, m;
    char c;
    cin >> n >> m;
    for(int i=0; i<m; i++) {
        int cld = 1;
        for(int j=1; j<=n; j++) {
            cin >> c;
            if(c == 'y') {
                cld += 0;
            }
            if(c == 'n') {
                cld += pow(2,n-j);
            }
        }
        cout << cld << endl;
    }
    
    return 0;
}
```

## 四、反思总结

根据题目要求找到规律，题目就很好解决了。

---

# PTA团队天梯赛║L1-072 刮刮彩票

## 一、题目要求

刮刮彩票”是一款网络游戏里面的一个小游戏。如图所示：![-362960_55cb6a89bf693.png](https://images.ptausercontent.com/e6f4f992-0e14-4a9f-bd2e-353c109dd196.png)

每次游戏玩家会拿到一张彩票，上面会有 9 个数字，分别为数字 1 到数字 9，数字各不重复，并以 3×3 的“九宫格”形式排布在彩票上。

在游戏开始时能看见一个位置上的数字，其他位置上的数字均不可见。你可以选择三个位置的数字刮开，这样玩家就能看见四个位置上的数字了。最后玩家再从 3 横、3 竖、2 斜共 8 个方向中挑选一个方向，方向上三个数字的和可根据下列表格进行兑奖，获得对应数额的金币。

| 数字合计 | 获得金币 | 数字合计 | 获得金币 |
| -------- | -------- | -------- | -------- |
| 6        | 10,000   | 16       | 72       |
| 7        | 36       | 17       | 180      |
| 8        | 720      | 18       | 119      |
| 9        | 360      | 19       | 36       |
| 10       | 80       | 20       | 306      |
| 11       | 252      | 21       | 1,080    |
| 12       | 108      | 22       | 144      |
| 13       | 72       | 23       | 1,800    |
| 14       | 54       | 24       | 3,600    |
| 15       | 180      |          |          |

现在请你写出一个模拟程序，模拟玩家的游戏过程。

### 输入格式:

输入第一部分给出一张合法的彩票，即用 3 行 3 列给出 0 至 9 的数字。**0 表示的是这个位置上的数字初始时就能看见了**，而不是彩票上的数字为 0。

第二部给出玩家刮开的三个位置，分为三行，每行按格式 `x y` 给出玩家刮开的位置的行号和列号（题目中定义左上角的位置为第 1 行、第 1 列。）。数据保证玩家不会重复刮开已刮开的数字。

最后一部分给出玩家选择的方向，即一个整数： 1 至 3 表示选择横向的第一行、第二行、第三行，4 至 6 表示纵向的第一列、第二列、第三列，7、8分别表示左上到右下的主对角线和右上到左下的副对角线。

### 输出格式:

对于每一个刮开的操作，在一行中输出玩家能看到的数字。最后对于选择的方向，在一行中输出玩家获得的金币数量。

### 输入样例:

```in
1 2 3
4 5 6
7 8 0
1 1
2 2
2 3
7
```

### 输出样例:

```out
1
5
6
180
```

## 二、解题思路

用一二维数组存放彩票的九宫格数字，因为输入时有一个 ‘0’ 代表初始可以看到的位置，但是其真实的数值并不为0，因此可以用 sum 求出输入的所有数字之和，最后用 45-sum的值就是 ‘0’ 所在位置的数值。之后根据输入执行相应的输出与求和操作，最后用一个数组存放对应的金币值，下标为对应的数字和。

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int a[5][5];
    int x, y;
    int sum = 0;
    for(int i=1; i<4; i++) {
        for(int j=1; j<4; j++) {
            cin >> a[i][j];
            sum += a[i][j];
            if(a[i][j] == 0) {
                x = i;
                y = j;
            }
        }
    }
    a[x][y] = 45 - sum;
    for(int i=0; i<3; i++) {
        cin >> x >> y;
        cout << a[x][y] << endl;
    }
    int n;
    cin >> n;
    sum = 0;
    if(n <= 3) {
        for(int i=1; i<4; i++)
            sum += a[n][i];
    }
    else if(n <= 6) {
        for(int i=1; i<4; i++)
            sum += a[i][n-3];
    }
    else if(n == 7) {
        for(int i=1; i<4; i++)
            sum += a[i][i];
    }
    else if(n == 8) {
        for(int i=1; i<4; i++)
            sum += a[i][4-i];
    }
    int gold[30] = {0,0,0,0,0,0,10000,36,720,360,80,252,108,72,54,180,72,180,119,36,306,1080,144,1800,3600};
    cout << gold[sum] << endl;
    
    return 0;
}
```

## 四、反思总结

这道题重点是理解题意，起初没有弄清楚输入的 ‘0’ 的含义，导致一直无法输出正确答案。

---

# PTA团队天梯赛║L2-003 月饼

## 一、题目要求

月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。

注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。

### 输入格式：

每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 *N* 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 *D* 表示市场最大需求量。随后一行给出 *N* 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 *N* 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。

### 输出格式：

对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。

### 输入样例：

```in
3 20
18 15 10
75 72 45
```

### 输出样例：

```out
94.50
```

## 二、解题思路

本题要想得到最大利润，一定要先卖单价高的月饼，因此创建一个月饼的结构体，存储其库存，总售价以及单价，根据输入的库存及总售价计算出单价。利用 *sort()* 函数按照各类月饼的单价降序排序，最后根据市场的最大需求从前向后遍历月饼数组，计算收益。

## 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;

struct mooncake {
    float stock;  //库存
    float totalsale;  //总售价
    float price;  //单价
};
bool cmp(mooncake m1, mooncake m2) {
    return m1.price > m2.price;
}

int main() {
    int n;
    cin >> n;
    int demand;
    cin >> demand;
    struct mooncake mc[n];
    for(int i=0; i<n; i++) {
        cin >> mc[i].stock;
    }
    for(int i=0; i<n; i++) {
        cin >> mc[i].totalsale;
        mc[i].price = mc[i].totalsale / mc[i].stock;
    }
    sort(mc,mc+n,cmp);
    float sum = 0;
    for(int i=0; i<n; i++) {
        if(mc[i].stock <= demand) {
            sum += mc[i].totalsale;
        }
        else {
            sum += mc[i].price * demand;
            break;
        }
        demand -= mc[i].stock;
    }
    printf("%.2f\n",sum);
    
    return 0;
}
```

## 四、反思总结

C++中的 *sort()* 函数十分好用

```cpp
// 语法
sort(start,end,cmp)
// 参数
（1）start表示要排序数组的起始地址；
（2）end表示数组结束地址的下一位；
（3）cmp用于规定排序的方法，可不填，默认升序。

//示例一  sort函数没有第三个参数，实现的是从小到大（升序）排列：
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
    int a[10]={9,6,3,8,5,2,7,4,1,0};
    for(int i=0;i<10;i++)
    	cout<<a[i]<<endl;
    sort(a,a+10);//指针
    for(int i=0;i<10;i++)
    	cout<<a[i]<<endl;
    return 0;
}

//示例二 加入一个比较函数compare()，实现从大到小（降序）排列：
#include<iostream>
#include<algorithm>
using namespace std;
bool compare(int a,int b)
{   
	return a>b;
}
int main()
{
	int a[10]={9,6,3,8,5,2,7,4,1,0};
	for(int i=0;i<10;i++)
		cout<<a[i]<<endl;  
	sort(a,a+10,compare);//在这里就不需要对compare函数传入参数了   
	for(int i=0;i<10;i++)
		cout<<a[i]<<endl;
	return 0;
}

//示例三 有一个node类型的数组node arr[100]，想对它进行排序：先按a值升序排列，如果a值相同，再按b值降序排列，如果b还相同，就按c降序排列。就可以写一个比较函数：
bool cmp(node x,node y)
{    
	if(x.a!=y.a) return x.a<y.a;    
	if(x.b!=y.b) return x.b>y.b;    
	return x.c>y.c;
}
```

